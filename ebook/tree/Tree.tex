\chapter{Tree}

\section{Maximum Depth of Binary Tree} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

\subsubsection{Solution}

\begin{Code}
private int maxDepth(TreeNode node) {
    if (node == null) {
        return 0;
    }
    return Math.max(maxDepth(node.left), maxDepth(node.right)) + 1;
}
\end{Code}

\newpage

\section{Invert Binary Tree} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Invert a binary tree.
\begin{Code}
     4                              4
   /   \                          /   \
  2     7           to           7     2
 / \   / \                      / \   / \
1   3 6   9                    9   6 3   1
\end{Code}

\subsubsection{Solution I}

\begin{Code}
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }

    TreeNode right = root.right;
    root.right = invertTree(root.left);
    root.left = invertTree(right);
    return root;
}
\end{Code}

\subsubsection{Solution II}

\begin{Code}
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }

    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();

        TreeNode left = node.left;
        node.left = node.right;
        node.right = left;

        if (node.left != null) {
            queue.offer(node.left);
        }

        if (node.right != null) {
            queue.offer(node.right);
        }
    }

    return root;
}
\end{Code}

\newpage

\section{Same Tree} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given two binary trees, write a function to check if they are equal or not.

Two binary trees are considered equal if they are structurally identical and the nodes have the same value.

\subsubsection{Solution}

\begin{Code}
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }
    if (p == null || q == null) {
        return false;
    }
    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
\end{Code}

\newpage

\section{Binary Search Tree Iterator} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

\textbf{Note:} next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.

\subsubsection{Solution}

\begin{Code}
public class BSTIterator {

    private Stack<TreeNode> mStack;
    private TreeNode mCurNode;

    public BSTIterator(TreeNode root) {
        mStack = new Stack<TreeNode>();
        mCurNode = root;
    }

    public boolean hasNext() {
        return !mStack.isEmpty() || mCurNode != null;
    }

    public int next() {
        int result = -1;

        while (hasNext()) {
            if (mCurNode != null) {
                mStack.push(mCurNode);
                mCurNode = mCurNode.left;
            } else {
                mCurNode = mStack.pop();
                result = mCurNode.val;
                mCurNode = mCurNode.right;
                break;
            }
        }

        return result;
    }
}
\end{Code}

\newpage

\section{Unique Binary Search Trees} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

For example,

Given n = 3, there are a total of 5 unique BST's.
\begin{Code}
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
\end{Code}

\subsubsection{Solution}
\begin{Code}
public int numTrees(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] += dp[j] * dp[i - j - 1];
        }
    }

    return dp[n];
}
\end{Code}

\newpage

\section{Lowest Common Ancestor of a Binary Search Tree} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”
\begin{Code}
        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
\end{Code}
For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.

\subsubsection{Solution}

\begin{Code}
// 耗时9ms
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (!checkExist(root, p) || !checkExist(root, q)) {
        throw new IllegalArgumentException("Not exist!!");
    }

    while (root != null) {
        if (p.val < root.val && q.val < root.val) {
            root = root.left;
        } else if (p.val > root.val && q.val > root.val) {
            root = root.right;
        } else {
            break;
        }
    }
    return root;
}

/**
 * 如何判断p或q一定存在，如果是BST就很简单
 */
private boolean checkExist(TreeNode root, TreeNode node) {
    TreeNode cur = root;
    while (cur != null) {
        if (node.val > cur.val) {
            cur = cur.right;
        } else if (node.val < cur.val) {
            cur = cur.left;
        } else {
            return true;
        }
    }
    return false;
}
\end{Code}

\newpage

\section{Balanced Binary Tree} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

\subsubsection{Solution}

\begin{Code}
public boolean isBalanced(TreeNode root) {
    return isBalanced(root, null);
}

private boolean isBalanced(TreeNode root, int[] height) {
    if (root == null) {
        return true;
    }

    int[] left = new int[1], right = new int[1];

    boolean result = isBalanced(root.left, left) && isBalanced(root.right, right);

    if (height != null) {
        height[0] = Math.max(left[0], right[0]) + 1;
    }

    return result && Math.abs(left[0] - right[0]) <= 1;
}
\end{Code}

\newpage

\section{Binary Tree Maximum Path Sum} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given a binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

For example:

Given the below binary tree,
\begin{Code}
       1
      / \
     2   3
\end{Code}

Return 6.

\subsubsection{Solution}

\begin{Code}
public int maxPathSum(TreeNode root) {
    return maxPathSum(root, null);
}

/**
 * max表示包含root的单边路径最大和
 */
private int maxPathSum(TreeNode root, int[] max) {
    if (root == null) {
        return Integer.MIN_VALUE;  // 此处容易错
    }
    int[] left = new int[1], right = new int[1];
    int leftMax = maxPathSum(root.left, left);
    int rightMax = maxPathSum(root.right, right);
    if (max != null) {
        max[0] = max(left[0], right[0], 0) + root.val; // 此处容易错
    }

    // 容易错，要考虑到所有可能的情况
    return max(leftMax, rightMax, root.val, left[0] + right[0] + root.val,
            left[0] + root.val, right[0] + root.val);
}

private int max(int... vals) {
    int max = Integer.MIN_VALUE;
    for (int val : vals) {
        max = Math.max(max, val);
    }
    return max;
}
\end{Code}

\newpage

\section{Populating Next Right Pointers in Each Node} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given a binary tree
\begin{Code}
    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    }
\end{Code}

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

\textbf{Note:}

You may only use constant extra space.

You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).

For example,

Given the following perfect binary tree,
\begin{Code}
         1
       /  \
      2    3
     / \  / \
    4  5  6  7
\end{Code}

After calling your function, the tree should look like:
\begin{Code}
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \  / \
    4->5->6->7 -> NULL
\end{Code}

\newpage

\subsubsection{Solution I}

\begin{Code}
/** 递归法，巧妙地运用dummy使代码很简洁
 *  假定当前root所在层已连好，要连下一层
 */
public void connect(TreeLinkNode root) {
    if (root == null) {
        return;
    }
    TreeLinkNode dummy = new TreeLinkNode(0), cur = dummy;
    for (TreeLinkNode p = root; p != null; p = p.next) {
        if (p.left != null) {
            cur.next = p.left;
            cur = cur.next;
        }
        if (p.right != null) {
            cur.next = p.right;
            cur = cur.next;
        }
    }
    connect(dummy.next);
}

\end{Code}

\subsubsection{Solution II}

\begin{Code}
/**
 * 将递归转成非递归很简单，就加一层循环，且结尾处加root = dummy.next即可
 */
public void connect2(TreeLinkNode root) {
    while (root != null) {
        TreeLinkNode dummy = new TreeLinkNode(0), cur = dummy;

        for (TreeLinkNode p = root; p != null; p = p.next) {
            if (p.left != null) {
                cur.next = p.left;
                cur = cur.next;
            }
            if (p.right != null) {
                cur.next = p.right;
                cur = cur.next;
            }
        }

        root = dummy.next;
    }
}
\end{Code}

\newpage

\section{Convert Sorted Array to Binary Search Tree} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

\subsubsection{Solution}

\begin{Code}
public TreeNode sortedArrayToBST(int[] nums) {
    return sortedArrayToBST(nums, 0, nums.length);
}

private TreeNode sortedArrayToBST(int[] nums, int start, int end) {
    if (start >= end) {
        return null;
    }
    int mid = start + (end - start) / 2;
    TreeNode root = new TreeNode(nums[mid]);
    root.left = sortedArrayToBST(nums, start, mid);
    root.right = sortedArrayToBST(nums, mid + 1, end);
    return root;
}
\end{Code}

\newpage

