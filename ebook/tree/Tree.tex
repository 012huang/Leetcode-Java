\chapter{Tree}

\section{Maximum Depth of Binary Tree} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

\subsubsection{Solution}

\begin{Code}
private int maxDepth(TreeNode node) {
    if (node == null) {
        return 0;
    }
    return Math.max(maxDepth(node.left), maxDepth(node.right)) + 1;
}
\end{Code}

\newpage

\section{Invert Binary Tree} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Invert a binary tree.
\begin{Code}
     4                              4
   /   \                          /   \
  2     7           to           7     2
 / \   / \                      / \   / \
1   3 6   9                    9   6 3   1
\end{Code}

\subsubsection{Solution I}

\begin{Code}
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }

    TreeNode right = root.right;
    root.right = invertTree(root.left);
    root.left = invertTree(right);
    return root;
}
\end{Code}

\subsubsection{Solution II}

\begin{Code}
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }

    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();

        TreeNode left = node.left;
        node.left = node.right;
        node.right = left;

        if (node.left != null) {
            queue.offer(node.left);
        }

        if (node.right != null) {
            queue.offer(node.right);
        }
    }

    return root;
}
\end{Code}

\newpage

\section{Same Tree} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given two binary trees, write a function to check if they are equal or not.

Two binary trees are considered equal if they are structurally identical and the nodes have the same value.

\subsubsection{Solution}

\begin{Code}
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }
    if (p == null || q == null) {
        return false;
    }
    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
\end{Code}

\newpage

\section{Binary Search Tree Iterator} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

\textbf{Note:} next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.

\subsubsection{Solution}

\begin{Code}
public class BSTIterator {

    private Stack<TreeNode> mStack;
    private TreeNode mCurNode;

    public BSTIterator(TreeNode root) {
        mStack = new Stack<TreeNode>();
        mCurNode = root;
    }

    public boolean hasNext() {
        return !mStack.isEmpty() || mCurNode != null;
    }

    public int next() {
        int result = -1;

        while (hasNext()) {
            if (mCurNode != null) {
                mStack.push(mCurNode);
                mCurNode = mCurNode.left;
            } else {
                mCurNode = mStack.pop();
                result = mCurNode.val;
                mCurNode = mCurNode.right;
                break;
            }
        }

        return result;
    }
}
\end{Code}

\newpage

\section{Unique Binary Search Trees} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given n, how many structurally unique BST's (binary search trees) that store values 1...n?

For example,

Given n = 3, there are a total of 5 unique BST's.
\begin{Code}
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
\end{Code}

\subsubsection{Solution}
\begin{Code}
public int numTrees(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] += dp[j] * dp[i - j - 1];
        }
    }

    return dp[n];
}
\end{Code}

\newpage

\section{Lowest Common Ancestor of a Binary Search Tree} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”
\begin{Code}
        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
\end{Code}
For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.

\subsubsection{Solution}

\begin{Code}
// 耗时9ms
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (!checkExist(root, p) || !checkExist(root, q)) {
        throw new IllegalArgumentException("Not exist!!");
    }

    while (root != null) {
        if (p.val < root.val && q.val < root.val) {
            root = root.left;
        } else if (p.val > root.val && q.val > root.val) {
            root = root.right;
        } else {
            break;
        }
    }
    return root;
}

/**
 * 如何判断p或q一定存在，如果是BST就很简单
 */
private boolean checkExist(TreeNode root, TreeNode node) {
    TreeNode cur = root;
    while (cur != null) {
        if (node.val > cur.val) {
            cur = cur.right;
        } else if (node.val < cur.val) {
            cur = cur.left;
        } else {
            return true;
        }
    }
    return false;
}
\end{Code}

\newpage

\section{Balanced Binary Tree} %%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Description}

Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

\subsubsection{Solution}

\begin{Code}
public boolean isBalanced(TreeNode root) {
    return isBalanced(root, null);
}

private boolean isBalanced(TreeNode root, int[] height) {
    if (root == null) {
        return true;
    }

    int[] left = new int[1], right = new int[1];

    boolean result = isBalanced(root.left, left) && isBalanced(root.right, right);

    if (height != null) {
        height[0] = Math.max(left[0], right[0]) + 1;
    }

    return result && Math.abs(left[0] - right[0]) <= 1;
}
\end{Code}

\newpage