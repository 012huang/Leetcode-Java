283. Move Zeroes
Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.
For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].

Note:
You must do this in-place without making a copy of the array.
Minimize the total number of operations.

public void moveZeroes(int[] nums) {
	for (int i = 0, left = 0; left < nums.length; ) {
		if (i < nums.length) {
			if (nums[i] != 0) {
				nums[left++] = nums[i];
			}
			i++;
		} else {
			nums[left++] = 0;
		}
	}
}

325. Maximum Size Subarray Sum Equals k
Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.

Note:
The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.

Example 1:
Given nums = [1, -1, 5, -2, 3], k = 3,
return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)

Example 2:
Given nums = [-2, -1, 2, 1], k = 1,
return 2. (because the subarray [-1, 2] sums to 1 and is the longest)

Follow Up:
Can you do it in O(n) time?

// 耗时218ms，时间复杂度O(n^2)
public int maxSubArrayLen(int[] nums, int k) {
	int maxLen = 0;

	for (int i = 0; i < nums.length; i++) {
		for (int j = i, sum = 0; j >= 0; j--) {
			sum += nums[j];
			if (sum == k) {
				if (i - j + 1 > maxLen) {
					maxLen = i - j + 1;
				}
			}
		}
	}

	return maxLen;
}

// 耗时29ms，时间复杂度O(n)
public int maxSubArrayLen2(int[] nums, int k) {
	HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();

	for (int i = 0; i < nums.length; i++) {
		nums[i] += i > 0 ? nums[i - 1] : 0;

		// 这里要注意判重，map中保存最靠左的，这样子序列能更长
		if (!map.containsKey(nums[i])) {
			map.put(nums[i], i);
		}
	}

	int maxLen = 0;
	for (int i = 0; i < nums.length; i++) {
		if (nums[i] == k) {
			maxLen = i + 1;
		} else if (map.containsKey(nums[i] - k)) {
			int index = map.get(nums[i] - k);
			if (index < i) {
				maxLen = Math.max(maxLen, i - index);
			}
		}
	}
	return maxLen;
}

301. Remove Invalid Parentheses
Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.

Note: The input string may contain letters other than the parentheses ( and ).

Examples:
"()())()" -> ["()()()", "(())()"]
"(a)())()" -> ["(a)()()", "(a())()"]
")(" -> [""]

// 耗时97ms
public List<String> removeInvalidParentheses(String s) {
	if (s.length() == 0) {
		return Arrays.asList(s);
	}

	Queue<String> queue = new LinkedList<String>();
	queue.add(s);

	Queue<String> next = new LinkedList<String>();

	HashSet<String> visited = new HashSet<String>();

	List<String> result = new LinkedList<String>();

	while (!queue.isEmpty()) {
		String ss = queue.poll();

		if (isValidParentheses(ss)) {
			result.add(ss);
		}

		if (result.isEmpty()) {
			for (int i = 0; i < ss.length(); i++) {
				char c = ss.charAt(i);
				if (c != '(' && c != ')') {
					continue;
				}
				String sub = ss.substring(0, i) + ss.substring(i + 1);
				if (!visited.contains(sub)) {
					visited.add(sub);
					queue.add(sub);
				}
			}
		}

		if (queue.isEmpty()) {
			if (result.isEmpty()) {
				Queue<String> temp = queue;
				queue = next;
				next = temp;
			} else {
				return result;
			}
		}
	}

	return result;
}

private boolean isValidParentheses(String s) {
	if (s.length() == 0) {
		return true;
	}

	int count = 0;
	char[] ss = s.toCharArray();
	for (char c : ss) {
		if (c == '(') {
			count++;
		} else if (c == ')') {
			if (--count < 0) {
				return false;
			}
		}
	}

	return count == 0;
}

// 耗时9ms，时间复杂度仍然是O(n*2^n)，只不过这里剪枝很多
public List<String> removeInvalidParentheses2(String s) {
	if (s.length() == 0) {
		return Arrays.asList("");
	}
	int nL = 0, nR = 0;
	char[] ss = s.toCharArray();
	for (char c : ss) {
		if (c == '(') {
			nL++;
		} else if (c == ')') {
			if (nL > 0) {
				nL--;
			} else {
				nR++;
			}
		}
	}
	HashSet<String> set = new HashSet<>();
	dfs(s, 0, set, new StringBuilder(), nL, nR, 0);
	return new LinkedList<String>(set);
}

private void dfs(String s, int i, HashSet<String> set, StringBuilder sb, int nL, int nR, int count) {
	if (nL < 0 || nR < 0 || count < 0) {
		return;
	}

	if (i == s.length()) {
		if (nL == 0 && nR == 0 && count == 0) {
			set.add(sb.toString());
		}
		return;
	}

	char c = s.charAt(i);
	int len = sb.length();

	// 要注意下面都要先处理不带c，再处理带c的情况
	if (c == '(') {
		dfs(s, i + 1, set, sb, nL - 1, nR, count);
		dfs(s, i + 1, set, sb.append(c), nL, nR, count + 1);
	} else if (c == ')') {
		dfs(s, i + 1, set, sb, nL, nR - 1, count);
		dfs(s, i + 1, set, sb.append(c), nL, nR, count - 1);
	} else {
		dfs(s, i + 1, set, sb.append(c), nL, nR, count);
	}

	sb.setLength(len);
}

311. Sparse Matrix Multiplication
Given two sparse matrices A and B, return the result of AB.

You may assume that A's column number is equal to B's row number.

Example:

A = [
  [ 1, 0, 0],
  [-1, 0, 3]
]

B = [
  [ 7, 0, 0 ],
  [ 0, 0, 0 ],
  [ 0, 0, 1 ]
]


     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |
AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |
                  | 0 0 1 |
				  
public int[][] multiply(int[][] A, int[][] B) {
	int M = A.length, T = B.length, N = B[0].length;

	int[][] C = new int[M][N];

	for (int i = 0; i < M; i++) {
		for (int j = 0; j < T; j++) {
			if (A[i][j] != 0) {
				for (int k = 0; k < N; k++) {
					if (B[j][k] != 0) {
						C[i][k] += A[i][j] * B[j][k];
					}
				}
			}
		}
	}

	return C;
}

314. Binary Tree Vertical Order Traversal
Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column).

If two nodes are in the same row and column, the order should be from left to right.

Examples:

Given binary tree [3,9,20,null,null,15,7],
   3
  /\
 /  \
 9  20
    /\
   /  \
  15   7
return its vertical order traversal as:
[
  [9],
  [3,15],
  [20],
  [7]
]
Given binary tree [3,9,8,4,0,1,7],
     3
    /\
   /  \
   9   8
  /\  /\
 /  \/  \
 4  01   7
return its vertical order traversal as:
[
  [4],
  [9],
  [3,0,1],
  [8],
  [7]
]
Given binary tree [3,9,8,4,0,1,7,null,null,null,2,5] (0's right child is 2 and 1's left child is 5),
     3
    /\
   /  \
   9   8
  /\  /\
 /  \/  \
 4  01   7
    /\
   /  \
   5   2
return its vertical order traversal as:
[
  [4],
  [9,5],
  [3,0,1],
  [8,2],
  [7]
]

// 耗时2ms
public List<List<Integer>> levelOrder(TreeNode root) {
	List<List<Integer>> result = new LinkedList<List<Integer>>();

	if (root == null) {
		return result;
	}

	Queue<TreeNode> queue = new LinkedList<TreeNode>();
	Queue<TreeNode> next = new LinkedList<TreeNode>();
	queue.add(root);

	List<Integer> cur = null;

	while (!queue.isEmpty()) {
		TreeNode node = queue.poll();

		if (cur == null) {
			cur = new LinkedList<Integer>();
			result.add(cur);
		}

		cur.add(node.val);

		if (node.left != null) {
			next.add(node.left);
		}

		if (node.right != null) {
			next.add(node.right);
		}

		if (queue.isEmpty()) {
			Queue<TreeNode> temp = queue;
			queue = next;
			next = temp;
			cur = null; // 注意这里要置空
		}
	}

	return result;
}

67. Add Binary
Given two binary strings, return their sum (also a binary string).

For example,
a = "11"
b = "1"
Return "100".

public String addBinary(String a, String b) {
	StringBuilder sb = new StringBuilder();

	int lena = a.length();
	int lenb = b.length();

	int carry = 0;

	for (int i = lena - 1, j = lenb - 1; i >= 0 || j >= 0 || carry > 0; i--, j--) {
		int n1 = (i >= 0 ? a.charAt(i) - '0' : 0);
		int n2 = (j >= 0 ? b.charAt(j) - '0' : 0);
		int sum = n1 + n2 + carry;

		sb.insert(0, sum & 1);
		carry = sum >> 1;
	}

	return sb.toString();
}

278. First Bad Version
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

public int firstBadVersion(int n) {
	int left = 1, right = n;

	while (left < right) {
		int mid = left + ((right - left) >>> 1);

		if (isBadVersion(mid)) {
			right = mid;
		} else {
			left = mid + 1;
		}
	}

	return left;
}

273. Integer to English Words
Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.

For example,
123 -> "One Hundred Twenty Three"
12345 -> "Twelve Thousand Three Hundred Forty Five"
1234567 -> "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
Hint:

Did you see a pattern in dividing the number into chunk of words? For example, 123 and 123000.
Group the number by thousands (3 digits). You can write a helper function that takes a number less than 1000 and convert just that chunk to words.
There are many edge cases. What are some good test cases? Does your code work with input such as 0? Or 1000010? (middle chunk is zero and should not be printed out)

private final String[] LESS_20 = {
		"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve",
		"Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"
};

private final String[] LESS_100 = {
		"", "Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"
};

private final String[] THOUSANDS = {
		"", "Thousand", "Million", "Billion"
};

// 耗时31ms，性能不怎么样，而且代码复杂，容易出错
public String numberToWords(int num) {
	if (num == 0) {
		return "zero";
	}

	StringBuilder sb = new StringBuilder();

	for (int i = 0; num > 0; num /= 1000, i++) {
		StringBuilder sb2 = new StringBuilder();

		int n = num % 1000;

		if (n == 0) {
			continue;
		}

		int hundred = n / 100;
		if (hundred > 0) {
			sb2.append(String.format(" %s hundred", LESS_20[hundred]));
		}

		n %= 100;

		if (n >= 20) {
			sb2.append(String.format(" %s", LESS_100[n / 10]));
			if (n % 10 != 0) {
				sb2.append(String.format(" %s", LESS_20[n % 10]));
			}

		} else if (n > 0) {
			sb2.append(String.format(" %s", LESS_20[n]));
		}

		sb.insert(0, String.format("%s %s", sb2.toString(), THOUSANDS[i]));
	}

	return sb.toString().trim();
}

// 这种写法耗时4ms，简洁效率还高
public String numberToWords2(int num) {
	if (num == 0) return "Zero";

	int i = 0;
	String words = "";

	while (num > 0) {
		if (num % 1000 != 0)
			words = helper(num % 1000) + THOUSANDS[i] + " " + words;
		num /= 1000;
		i++;
	}

	return words.trim();
}

private String helper(int num) {
	if (num == 0)
		return "";
	else if (num < 20)
		return LESS_20[num] + " ";
	else if (num < 100)
		return LESS_100[num / 10] + " " + helper(num % 10);
	else
		return LESS_20[num / 100] + " Hundred " + helper(num % 100);
}

252. Meeting Rooms
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.

For example,
Given [[0, 30],[5, 10],[15, 20]],
return false.

// 时间复杂度O(nlgn)
public boolean canAttendMeetings(Interval[] intervals) {
	Arrays.sort(intervals, new Comparator<Interval>() {
		@Override
		public int compare(Interval o1, Interval o2) {
			return o1.start > o2.start ? 1 : -1;
		}
	});

	for (int i = 1; i < intervals.length; i++) {
		if (intervals[i].start < intervals[i - 1].end) {
			return false;
		}
	}

	return true;
}

253. Meeting Rooms II
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.

For example,
Given [[0, 30],[5, 10],[15, 20]],
return 2.

// 耗时17ms，时间复杂度O(nlgn)
public int minMeetingRooms(Interval[] intervals) {
	Arrays.sort(intervals, new Comparator<Interval>() {
		@Override
		public int compare(Interval o1, Interval o2) {
			return o1.start > o2.start ? 1 : -1;
		}
	});

	Queue<Interval> queue = new PriorityQueue<Interval>(new Comparator<Interval>() {
		@Override
		public int compare(Interval o1, Interval o2) {
			return o1.end > o2.end ? 1 : -1;
		}
	});

	for (Interval interval : intervals) {
		if (queue.isEmpty() || interval.start < queue.peek().end) {
			queue.add(interval);
		} else {
			queue.poll();
			queue.add(interval);
		}
	}

	return queue.size();
}

17. Letter Combinations of a Phone Number
Given a digit string, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below.

Input:Digit string "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
Note:
Although the above answer is in lexicographical order, your answer could be in any order you want.

private final String[] ARR = {
		"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
};

// 耗时3ms
public List<String> letterCombinations(String digits) {
	if (digits.length() == 0) {
		return Collections.emptyList();
	}

	List<String> result = new ArrayList<String>();
	helper(digits, 0, result, new StringBuilder());
	return result;
}

private void helper(String digits, int start, List<String> list, StringBuilder sb) {
	if (start >= digits.length()) {
		list.add(sb.toString());
		return;
	}

	String s = ARR[digits.charAt(start) - '0'];

	// 这里要注意单独拿出来处理
	if (s.length() == 0) {
		helper(digits, start + 1, list, sb);
		return;
	}

	for (int i = 0; i < s.length(); i++) {
		int len = sb.length();
		sb.append(s.charAt(i));
		helper(digits, start + 1, list, sb);
		sb.setLength(len);
	}
}

91. Decode Ways
A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -> 1
'B' -> 2
...
'Z' -> 26
Given an encoded message containing digits, determine the total number of ways to decode it.

For example,
Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

The number of ways decoding "12" is 2.

/** 思路一
// 超时了，有大量的字符串复制，不过思路挺直观的
public int numDecodings(String s) {
	if (s.length() == 0) {
		return 0;
	}
	return helper(s);
}

public int helper(String s) {
	// 如果能一直正确匹配到结尾了是合法的
	if (s.length() == 0) {
		return 1;
	}

	// 以0开头的是非法的
	if (s.charAt(0) == '0') {
		return 0;
	}

	int ways = 0;

	if (s.length() > 1 && (s.charAt(0) == '1' || (s.charAt(0) == '2' && (s.charAt(1) >= '0' && s.charAt(1) <= '6')))) {
		ways += helper(s.substring(2));
	}

	ways += helper(s.substring(1));

	return ways;
}
*/

/** 思路二
// 这里进行了优化，去掉了字符串复制，但有些cases仍然超时，因为仍然有大量重复运算
public int numDecodings(String s) {
	if (s.length() == 0) {
		return 0;
	}
	return helper(s.toCharArray(), 0);
}

public int helper(char[] s, int i) {
	if (i >= s.length) {
		return 1;
	}

	if (s[i] == '0') {
		return 0;
	}

	int ways = 0;

	if (i < s.length - 1 && (s[i] == '1' || (s[i] == '2' && (s[i + 1] >= '0' && s[i + 1] <= '6')))) {
		ways += helper(s, i + 2);
	}

	ways += helper(s, i + 1);
	return ways;
}
*/

/**
 * 思路三
// 这里继续优化，为避免重复运算，对结果进行了缓存，性能非常好
public int numDecodings(String s) {
	if (s.length() == 0) {
		return 0;
	}
	int[] f = new int[s.length()];
	Arrays.fill(f, -1);
	return helper(s.toCharArray(), f, 0);
}

public int helper(char[] s, int[] f, int i) {
	if (i >= s.length) {
		return 1;
	}

	if (s[i] == '0') {
		f[i] = 0;
		return 0;
	}

	if (f[i] >= 0) {
		return f[i];
	}

	int ways = 0;

	if (i < s.length - 1 && (s[i] == '1' || (s[i] == '2' && (s[i + 1] >= '0' && s[i + 1] <= '6')))) {
		ways += helper(s, f, i + 2);
	}

	ways += helper(s, f, i + 1);

	f[i] = ways;

	return ways;
}
*/

// DP，耗时2ms，复杂度O(n)
public int numDecodings(String s) {
	if (s == null || s.length() == 0) {
		return 0;
	}

	int len = s.length();

	int[] f = new int[len + 1];

	f[0] = 1;
	f[1] = s.charAt(0) == '0' ? 0 : 1;

	for (int i = 2; i <= len; i++) {
		if (s.charAt(i - 2) == '1' || (s.charAt(i - 2) == '2' && s.charAt(i - 1) <= '6')) {
			f[i] = f[i - 2];
		}

		if (s.charAt(i - 1) != '0') {
			f[i] += f[i - 1];
		}
	}

	return f[len];
}

10. Regular Expression Matching
Implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true

// 耗时153ms
public boolean isMatch(String s, String p) {
	// 如果p是空串，那么s必须也是空串
	if (p.length() == 0) {
		return s.length() == 0;
	}

	// 如果p只有一个字符，那么s必须也是1个字符，而且两者要匹配，注意p不会是单独的*，因为*要跟在某个字符后面
	if (p.length() == 1) {
		return s.length() == 1 && isMatch(s, 0, p);
	}

	if (p.charAt(1) != '*') {
		if (s.length() < 1) {
			return false;
		}

		return isMatch(s, 0, p) && isMatch(s.substring(1), p.substring(1));
	} else {
		// 这里要注意判断s是否为空
		if (s.length() > 0 && isMatch(s, 0, p)) {
			return isMatch(s, p.substring(2)) || isMatch(s.substring(1), p);
		} else {
			return isMatch(s, p.substring(2));
		}
	}
}

private boolean isMatch(String s, int i, String p) {
	return s.charAt(i) == p.charAt(0) || p.charAt(0) == '.';
}

44. Wildcard Matching
Implement wildcard pattern matching with support for '?' and '*'.

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false

// 这道题关键是遇到"*"的处理以及后面匹配失败时的回溯
// 只要有"*"，当后面匹配失败时就有重试的机会
public boolean isMatch(String s, String p) {
	int is = 0, ip = 0, ks = -1, kp = -1;

	while (is < s.length()) {
		// 如果当前能匹配则往下走
		if (ip < p.length() && (s.charAt(is) == p.charAt(ip) || p.charAt(ip) == '?')) {
			is++;
			ip++;
		} else if (ip < p.length() && p.charAt(ip) == '*') {
			// 如果遇到"*"记下s和p当前位置，便于后面匹配失败时回溯，遇到新的"*"时会覆盖之前的"*"
			ks = is;
			kp = ip;
			ip++;
		} else if (kp != -1) {
			// 如果p到头了，或者匹配失败了，回归到之前记下的位置，注意每次回溯时的p的位置都是固定的，但是
			// 回溯时的s的位置每次都要加1，因为上次的位置是失败的，所以这次回溯要跳过上次的位置
			is = ++ks;
			ip = kp + 1;
		} else {
			// p到头了，或者匹配失败了，但是没有可回溯的
			return false;
		}
	}

	for ( ; ip < p.length() && p.charAt(ip) == '*'; ip++);
	return ip == p.length();
}

157. Read N Characters Given Read4
The API: int read4(char *buf) reads 4 characters at a time from a file.

The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.

By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.

Note:
The read function will only be called once for each test case.

public int read(char[] buf, int n) {
	char[] tmp = new char[4];
	for (int i = 0; i < n; ) {
		int k = read4(tmp);
		// 这里i<n很容易忽略
		for (int j = 0; i < n && j < k; ) {
			buf[i++] = tmp[j++];
		}
		if (k < 4) {
			return i;
		}
	}
	return n;
}

158. Read N Characters Given Read4 II - Call multiple times
The API: int read4(char *buf) reads 4 characters at a time from a file.

The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.

By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.

Note:
The read function may be called multiple times.

private char[] temp = new char[4];
private int index, size;

public int read(char[] buf, int n) {
	for (int i = 0; i < n; ) {
		// 先读之前没读完的
		while (i < n && index < size) {
			buf[i++] = temp[index++];
		}

		// 如果读够了先返回，否则重置
		if (i >= n) {
			return n;
		} else {
			index = 0;
			size = 0;
		}

		if (i < n) {
			if ((size = read4(temp)) == 0) {
				return i;
			}
		}
	}
	return n;
}

15. 3Sum
Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note: The solution set must not contain duplicate triplets.

For example, given array S = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]

// 耗时30ms
public List<List<Integer>> threeSum(int[] nums) {
	List<List<Integer>> result = new LinkedList<List<Integer>>();

	if (nums.length == 0) {
		return result;
	}

	Arrays.sort(nums);

	for (int i = 0; i < nums.length - 2; i++) {
		if (i > 0 && nums[i] == nums[i - 1]) {
			continue;
		}

		int sum = -nums[i];

		for (int j = i + 1, k = nums.length - 1; j < k; ) {
			int m = nums[j] + nums[k];
			if (m > sum) {
				k--;
			} else if (m < sum) {
				j++;
			} else {
				result.add(Arrays.asList(nums[i], nums[j], nums[k]));
				for (++j, --k; j < k && nums[j] == nums[j - 1] && nums[k] == nums[k + 1]; j++, k--);
			}
		}
	}

	return result;
}

277. Find the Celebrity
Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.

Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).

You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.

Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.

public int findCelebrity(int n) {
	int candidate = 0;

	for (int i = 1; i < n; i++) {
		if (knows(candidate, i)) {
			candidate = i;
		}
	}

	for (int i = 0; i < n; i++) {
		if (candidate == i) {
			continue;
		}
		if (knows(candidate, i) || !knows(i, candidate)) {
			return -1;
		}
	}

	return candidate;
}

285. Inorder Successor in BST
Given a binary search tree and a node in it, find the in-order successor of that node in the BST.

Note: If the given node has no in-order successor in the tree, return null.

private boolean found;
private TreeNode succesor;

// 耗时5ms
public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
	traverse(root, p);
	return succesor;
}

private void traverse(TreeNode node, TreeNode p) {
	if (node == null) {
		return;
	}

	traverse(node.left, p);

	if (node == p) {
		found = true;
	} else if (found && succesor == null) {
		succesor = node;
		return;
	}

	traverse(node.right, p);
}

// 耗时4ms
public TreeNode inorderSuccessor2(TreeNode root, TreeNode p) {
	TreeNode res = null;
	while (root != null) {
		if (root.val > p.val) {
			res = root;
			root = root.left;
		} else {
			root = root.right;
		}
	}
	return res;
}

297. Serialize and Deserialize Binary Tree
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

For example, you may serialize the following tree

    1
   / \
  2   3
     / \
    4   5
as "[1,2,3,null,null,4,5]", just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.
Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.

public class Codec {

    // 这里的分隔符是有讲究的，如果换成'.'则在split的时候要转义，但是','不用
    private static final String SEP = ".";

    // 这个尽可能短，节省空间
    private static final String NULL = "X";

    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serialize(root, sb);
        return sb.toString();
    }

    private void serialize(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL).append(SEP);
        } else {
            sb.append(root.val).append(SEP);
            serialize(root.left, sb);
            serialize(root.right, sb);
        }
    }

    public TreeNode deserialize(String data) {
        Queue<String> queue = new LinkedList<String>();
        queue.addAll(Arrays.asList(data.split(SEP)));
        return deserialize(queue);
    }

    private TreeNode deserialize(Queue<String> queue) {
        if (queue.isEmpty()) {
            return null;
        }

        String s = queue.poll();

        if (s.equals(NULL)) {
            return null;
        }

        TreeNode root = new TreeNode(Integer.valueOf(s));
        root.left = deserialize(queue);
        root.right = deserialize(queue);
        return root;
    }
}

161. One Edit Distance
Given two strings S and T, determine if they are both one edit distance apart.

// 耗时1ms
public boolean isOneEditDistance(String s, String t) {
	if (s.length() < t.length()) {
		return isOneEditDistance(t, s);
	}

	if (s.length() - t.length() > 1) {
		return false;
	}

	char[] ss = s.toCharArray();
	char[] tt = t.toCharArray();

	for (int i = 0; i < ss.length; i++) {
		if (i >= tt.length || ss[i] != tt[i]) {
			if (ss.length == tt.length) {
				return equals(ss, i + 1, tt, i + 1);
			} else {
				return equals(ss, i + 1, tt, i);
			}
		}
	}

	return false;
}

private boolean equals(char[] s, int si, char[] t, int ti) {
	for ( ; si < s.length && ti < t.length && s[si] == t[ti]; si++, ti++);
	return si == s.length && ti == t.length;
}

200. Number of Islands
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:

11110
11010
11000
00000
Answer: 1

Example 2:

11000
11000
00100
00011
Answer: 3

public int numIslands(char[][] grid) {
	if (grid.length == 0) {
		return 0;
	}

	int row = grid.length;
	int col = grid[0].length;

	int count = 0;

	for (int i = 0; i < row; i++) {
		for (int j = 0; j < col; j++) {
			if (grid[i][j] == '1') {
				count++;
				dfs(grid, i, j);
			}
		}
	}

	return count;
}

// 耗时3ms
private void dfs(char[][] grid, int i, int j) {
	if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {
		return;
	}

	if (grid[i][j] != '1') {
		return;
	}

	grid[i][j] = '0';
	dfs(grid, i + 1, j);
	dfs(grid, i - 1, j);
	dfs(grid, i, j + 1);
	dfs(grid, i, j - 1);
}

// 耗时12ms
private void bfs(char[][] grid, int i, int j) {
	Queue<int[]> queue = new LinkedList<int[]>();
	queue.add(new int[] {i, j});

	while (!queue.isEmpty()) {
		int[] position = queue.poll();

		i = position[0];
		j = position[1];

		if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {
			continue;
		}

		if (grid[i][j] != '1') {
			continue;
		} else {
			grid[i][j] = '0';
		}

		queue.add(new int[] {i + 1, j});
		queue.add(new int[] {i - 1, j});
		queue.add(new int[] {i, j + 1});
		queue.add(new int[] {i, j - 1});
	}

}

21. Merge Two Sorted Lists
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

// 耗时15ms
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	ListNode dummy = new ListNode(0);
	ListNode p = l1, q = l2, cur = dummy;
	for ( ; p != null && q != null; ) {
		if (p.val < q.val) {
			cur.next = p;
			p = p.next;
		} else {
			cur.next = q;
			q = q.next;
		}
		cur = cur.next;
	}
	cur.next = p != null ? p : q;
	return dummy.next;
}

// 耗时14ms，这个由于没有new dummy，所以应该会比上面快一些
public ListNode mergeTwoLists2(ListNode l1, ListNode l2) {
	if (l1 == null) {
		return l2;
	}
	if (l2 == null) {
		return l1;
	}
	if (l1.val < l2.val) {
		l1.next = mergeTwoLists2(l1.next, l2);
		return l1;
	} else {
		l2.next = mergeTwoLists2(l1, l2.next);
		return l2;
	}
}

23. Merge k Sorted Lists
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

// 耗时296ms，超时了
// 时间为2k + 3k + 4k + ... + nk
// 时间复杂度O(n^2 * k)，n为链表条数，k为链表平均长度
public ListNode mergeKLists(ListNode[] lists) {
	ListNode head = null;
	for (ListNode node : lists) {
		head = mergeTwoLists(head, node);
	}
	return head;
}

private ListNode mergeTwoLists(ListNode nodeA, ListNode nodeB) {
	ListNode dummy = new ListNode(0), cur = dummy;
	for ( ; nodeA != null && nodeB != null; ) {
		if (nodeA.val < nodeB.val) {
			cur.next = nodeA;
			nodeA = nodeA.next;
		} else {
			cur.next = nodeB;
			nodeB = nodeB.next;
		}
		cur = cur.next;
	}
	cur.next = nodeA != null ? nodeA : nodeB;
	return dummy.next;
}

// 耗时23ms
// 时间复杂度为O(knlgn)
public ListNode mergeKLists2(ListNode[] lists) {
	Queue<ListNode> queue = new PriorityQueue<ListNode>(new Comparator<ListNode>() {
		@Override
		public int compare(ListNode o1, ListNode o2) {
			return o1.val > o2.val ? 1 : -1;
		}
	});

	for (ListNode node : lists) {
		if (node != null) {
			queue.add(node);
		}
	}

	ListNode dummy = new ListNode(0), cur = dummy;

	while (!queue.isEmpty()) {
		ListNode node = queue.poll();

		cur.next = node;
		cur = cur.next;

		if (node.next != null) {
			queue.add(node.next);
		}
	}

	return dummy.next;
}

// 耗时18ms，比前两种方法都快
// T(n)=2T(n/2)+kn，时间复杂度为O(knlgn)
public ListNode mergeKLists3(ListNode[] lists) {
	return mergeKLists3(lists, 0, lists.length - 1);
}

private ListNode mergeKLists3(ListNode[] lists, int start, int end) {
	if (start == end) {
		return lists[start];
	} else if (start > end) {
		return null;
	} else {
		int mid = start + ((end - start) >>> 1);
		return mergeTwoLists(mergeKLists3(lists, start, mid), mergeKLists3(lists, mid + 1, end));
	}
}

76. Minimum Window Substring
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

For example,
S = "ADOBECODEBANC"
T = "ABC"
Minimum window is "BANC".

Note:
If there is no such window in S that covers all characters in T, return the empty string "".

If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.

// 耗时8ms，时间复杂度O(n)
public String minWindow(String s, String t) {
	char[] ss = s.toCharArray();
	char[] tt = t.toCharArray();

	int CHAR_MAX = 256;
	int[] cns = new int[CHAR_MAX];
	int[] cnt = new int[CHAR_MAX];

	for (char c : tt) {
		cnt[c]++;
	}

	// 这个k相当重要，好好体会一下为什么
	int start = 0, k = 0, minLen = Integer.MAX_VALUE;

	for (int i = 0, j = 0; j < ss.length; j++) {
		char c = ss[j];

		if (cnt[c] <= 0) {
			continue;
		}

		if (++cns[c] <= cnt[c]) {
			k++;
		}

		if (k >= tt.length) {
			for ( ; i <= j; i++) {
				c = ss[i];

				if (cnt[c] <= 0) {
					continue;
				}

				if (cns[c] > cnt[c]) {
					cns[c]--;
				} else {
					break;
				}
			}

			if (j - i + 1 <= minLen) {
				minLen = j - i + 1;
				start = i;
			}
		}
	}

	return minLen == Integer.MAX_VALUE ? "" : s.substring(start, start + minLen);
}

282. Expression Add Operators
Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.

Examples: 
"123", 6 -> ["1+2+3", "1*2*3"] 
"232", 8 -> ["2*3+2", "2+3*2"]
"105", 5 -> ["1*0+5","10-5"]
"00", 0 -> ["0+0", "0-0", "0*0"]
"3456237490", 9191 -> []

public List<String> addOperators(String num, int target) {
	List<String> rst = new LinkedList<String>();
	if (num == null || num.length() == 0) return rst;
	helper(rst, "", num, target, 0, 0, 0);
	return rst;
}

public void helper(List<String> rst, String path, String num, int target, int pos, long eval, long last) {
	if (pos == num.length()) {
		if (target == eval) {
			rst.add(path);
		}
		return;
	}

	for (int i = pos; i < num.length(); i++) {
		if (i != pos && num.charAt(pos) == '0') break;
		long cur = Long.parseLong(num.substring(pos, i + 1));
		if (pos == 0) {
			// 从pos=0开始的，所以不参与运算，只是组成第一个数
			helper(rst, path + cur, num, target, i + 1, cur, cur);
		} else {
			helper(rst, path + "+" + cur, num, target, i + 1, eval + cur, cur);

			helper(rst, path + "-" + cur, num, target, i + 1, eval - cur, -cur);

			helper(rst, path + "*" + cur, num, target, i + 1, eval - last + last * cur, last * cur);
		}
	}
}

257. Binary Tree Paths
Given a binary tree, return all root-to-leaf paths.

For example, given the following binary tree:

   1
 /   \
2     3
 \
  5
All root-to-leaf paths are:

["1->2->5", "1->3"]

/**
    // 耗时31ms，性能不太好
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> list = new LinkedList<String>();
        if (root == null) {
            return list;
        }
        StringBuilder sb = new StringBuilder(String.format("%d", root.val));
        traverse(root, list, sb);
        return list;
    }

    private void traverse(TreeNode node, List<String> list, StringBuilder sb) {
        if (node == null) {
            return;
        }

        if (node.left == null && node.right == null) {
            list.add(sb.toString());
            return;
        }

        if (node.left != null) {
            int len = sb.length();
            sb.append(String.format("->%d", node.left.val));
            traverse(node.left, list, sb);
            sb.setLength(len);
        }

        if (node.right != null) {
            int len = sb.length();
            sb.append(String.format("->%d", node.right.val));
            traverse(node.right, list, sb);
            sb.setLength(len);
        }
    }
*/

/** 针对上面写法的改进，去掉String.format()，耗时降到了2ms
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> list = new LinkedList<String>();
        if (root == null) {
            return list;
        }
        StringBuilder sb = new StringBuilder();
        sb.append(root.val);
        traverse(root, list, sb);
        return list;
    }

    private void traverse(TreeNode node, List<String> list, StringBuilder sb) {
        if (node == null) {
            return;
        }

        if (node.left == null && node.right == null) {
            list.add(sb.toString());
            return;
        }

        if (node.left != null) {
            int len = sb.length();
            sb.append("->").append(node.left.val);
            traverse(node.left, list, sb);
            sb.setLength(len);
        }

        if (node.right != null) {
            int len = sb.length();
            sb.append("->").append(node.right.val);
            traverse(node.right, list, sb);
            sb.setLength(len);
        }
    }
 */

// 耗时2ms，不用StringBuilder，直接用字符串相加，这样写更简洁
public List<String> binaryTreePaths(TreeNode root) {
	List<String> list = new LinkedList<String>();
	if (root == null) {
		return list;
	}
	traverse(root, list, String.valueOf(root.val));
	return list;
}

private void traverse(TreeNode node, List<String> list, String path) {
	if (node == null) {
		return;
	}

	if (node.left == null && node.right == null) {
		list.add(path);
		return;
	}

	if (node.left != null) {
		traverse(node.left, list, path + "->" + node.left.val);
	}

	if (node.right != null) {
		traverse(node.right, list, path + "->" + node.right.val);
	}
}

56. Merge Intervals
Given a collection of intervals, merge all overlapping intervals.

For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].

// 耗时26ms，时间复杂度O(nlgn)
public List<Interval> merge(List<Interval> intervals) {
	List<Interval> result = new LinkedList<Interval>();

	if (intervals.size() == 0) {
		return result;
	}

	Collections.sort(intervals, new Comparator<Interval>() {
		@Override
		public int compare(Interval o1, Interval o2) {
			return o1.start > o2.start ? 1 : - 1;
		}
	});

	int start = Integer.MAX_VALUE, end = Integer.MIN_VALUE;

	for (int i = 0; i < intervals.size(); i++) {
		Interval cur = intervals.get(i);

		if (i > 0 && cur.start > end) {
			result.add(new Interval(start, end));
			start = cur.start;
			end = cur.end;
		} else {
			start = Math.min(start, cur.start);
			end = Math.max(end, cur.end);
		}
	}

	result.add(new Interval(start, end));

	return result;
}

173. Binary Search Tree Iterator
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.

public class BSTIterator {

    private Stack<TreeNode> mStack;
    private TreeNode mCurNode;

    public BSTIterator(TreeNode root) {
        mStack = new Stack<TreeNode>();
        mCurNode = root;
    }

    /**
     * @return whether we have a next smallest number
     */
    public boolean hasNext() {
        return !mStack.isEmpty() || mCurNode != null;
    }

    /**
     * @return the next smallest number
     */
    public int next() {
        int result = -1;

        while (hasNext()) {
            if (mCurNode != null) {
                mStack.push(mCurNode);
                mCurNode = mCurNode.left;
            } else {
                mCurNode = mStack.pop();
                result = mCurNode.val;
                mCurNode = mCurNode.right;
                break;
            }
        }

        return result;
    }
}

121. Best Time to Buy and Sell Stock
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Example 1:
Input: [7, 1, 5, 3, 6, 4]
Output: 5

max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
Example 2:
Input: [7, 6, 4, 3, 1]
Output: 0

In this case, no transaction is done, i.e. max profit = 0.

public int maxProfit(int[] prices) {
	if (prices.length == 0) {
		return 0;
	}

	int min = prices[0], maxProfit = 0;

	for (int price : prices) {
		maxProfit = Math.max(maxProfit, price - min);
		min = Math.min(min, price);
	}

	return maxProfit;
}

122. Best Time to Buy and Sell Stock II
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }

    int profit = 0;

    for (int i = 1; i < prices.length; i++) {
        profit += Math.max(0, prices[i] - prices[i - 1]);
    }

    return profit;
}

123. Best Time to Buy and Sell Stock III
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }

    int len = prices.length;
    int[] left = new int[len];
    int[] right = new int[len];

    for (int i = 1, min = prices[0]; i < len; i++) {
        left[i] = Math.max(left[i - 1], prices[i] - min);
        min = Math.min(min, prices[i]);
    }

    for (int i = len - 2, max = prices[len - 1]; i >= 0; i--) {
        right[i] = Math.max(right[i + 1], max - prices[i]);
        max = Math.max(prices[i], max);
    }

    int profit = 0;
    for (int i = 0; i < len; i++) {
        profit = Math.max(profit, left[i] + right[i]);
    }

    return profit;
}

188. Best Time to Buy and Sell Stock IV
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

public int maxProfit(int k, int[] prices) {
    int len = prices.length;
    
    if (k >= len) {
        int sum = 0;
        for (int i = 1; i < len; i++) {
            sum += Math.max(0, prices[i] - prices[i - 1]);
        }
        return sum;
    }
    
    int[][] local = new int[len][k + 1];
    int[][] global = new int[len][k + 1];

    for (int i = 1; i < len; i++) {
        int diff = prices[i] - prices[i - 1];
        for (int j = 1; j <= k; j++) {
            local[i][j] = Math.max(global[i - 1][j - 1] + Math.max(0, diff), local[i - 1][j] + diff);
            global[i][j] = Math.max(local[i][j], global[i - 1][j]);
        }
    }

    return global[len - 1][k];
}

309. Best Time to Buy and Sell Stock with Cooldown
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:

You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
Example:

prices = [1, 2, 3, 0, 2]
maxProfit = 3
transactions = [buy, sell, cooldown, buy, sell]

public int maxProfit(int[] prices) {
    int sell = 0, prev_sell = 0, buy = Integer.MIN_VALUE, prev_buy;
    for (int price : prices) {
        prev_buy = buy;
        buy = Math.max(prev_sell - price, prev_buy);
        prev_sell = sell;
        sell = Math.max(prev_buy + price, prev_sell);
    }
    return sell;
}

1. Two Sum
Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution.

Example:
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
UPDATE (2016/2/13):
The return format had been changed to zero-based indices. Please read the above updated description carefully.

public int[] twoSum(int[] nums, int target) {
	Map<Integer, Integer> map = new HashMap<Integer, Integer>();

	for (int i = 0; i < nums.length; i++) {
		map.put(nums[i], i);
	}

	for (int i = 0; i < nums.length; i++) {
		if (map.containsKey(target - nums[i])) {
			int index = map.get(target - nums[i]);
			if (index != i) {
				return new int[] { i, index };
			}
		}
	}

	return null;
}

167. Two Sum II - Input array is sorted
Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution.

Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2

public int[] twoSum(int[] numbers, int target) {
	for (int i = 0, j = numbers.length - 1; i < j; ) {
		int sum = numbers[i] + numbers[j];
		if (sum > target) {
			j--;
		} else if (sum < target) {
			i++;
		} else {
			return new int[] {i + 1, j + 1};
		}
	}
	return null;
}

170. Two Sum III - Data structure design
Design and implement a TwoSum class. It should support the following operations: add and find.

add - Add the number to an internal data structure.
find - Find if there exists any pair of numbers which sum is equal to the value.

For example,
add(1); add(3); add(5);
find(4) -> true
find(7) -> false

139. Word Break
Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

For example, given
s = "leetcode",
dict = ["leet", "code"].

Return true because "leetcode" can be segmented as "leet code".

// 耗时12ms
public boolean wordBreak(String s, Set<String> wordDict) {
	int len = s.length();

	if (len == 0) {
		return false;
	}

	// 要注意用开区间
	boolean[] f = new boolean[len + 1];

	f[0] = true;

	for (int i = 1; i <= len; i++) {
		for (int j = 0; j < i; j++) {
			if (f[j] && wordDict.contains(s.substring(j, i))) {
				f[i] = true;
				break;
			}
		}
	}

	return f[len];
}

140. Word Break II
Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.

Return all such possible sentences.

For example, given
s = "catsanddog",
dict = ["cat", "cats", "and", "sand", "dog"].

A solution is ["cats and dog", "cat sand dog"].



211. Add and Search Word - Data structure design
Design a data structure that supports the following two operations:

void addWord(word)
bool search(word)
search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.

For example:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
Note:
You may assume that all words are consist of lowercase letters a-z.

click to show hint.

You should be familiar with how a Trie works. If not, please work on this problem: Implement Trie (Prefix Tree) first.

public class WordDictionary {

    private TrieNode mRoot = new TrieNode();

    // Adds a word into the data structure.
    public void addWord(String word) {
        TrieNode node = mRoot;
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if (node.nodes[c - 'a'] == null) {
                node.nodes[c - 'a'] = new TrieNode();
            }
            node = node.nodes[c - 'a'];
        }
        node.word = word;
    }

    // Returns if the word is in the data structure. A word could
    // contain the dot character '.' to represent any one letter.
    public boolean search(String word) {
        return search(mRoot, word, 0);
    }

    private boolean search(TrieNode node, String word, int start) {
        if (start == word.length()) {
            return node != null && node.word != null;
        }
        if (node == null) {
            return false;
        }
        if (word.charAt(start) != '.') {
            return search(node.nodes[word.charAt(start) - 'a'], word, start + 1);
        }
        for (int i = 0; i < 26; i++) {
            if (search(node.nodes[i], word, start + 1)) {
                return true;
            }
        }
        return false;
    }
}

75. Sort Colors
Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note:
You are not suppose to use the library's sort function for this problem.

Follow up:
A rather straight forward solution is a two-pass algorithm using counting sort.
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.

Could you come up with an one-pass algorithm using only constant space?

// 时间复杂度O(nlgn)
public void sortColors(int[] nums) {
	Arrays.sort(nums);
}

// 时间复杂度O(n)，不过要扫两遍
public void sortColors2(int[] nums) {
	int[] count = new int[3];
	for (int n : nums) {
		count[n]++;
	}

	for (int i = 0, k = 0; i < count.length; i++) {
		for (int j = 0; j < count[i]; j++) {
			nums[k++] = i;
		}
	}
}

// 时间复杂度O(n)，扫一遍
public void sortColors3(int[] nums) {
	int zero = -1, two = nums.length;
	for (int i = 0; i < two; ) {
		if (nums[i] == 0) {
			swap(nums, ++zero, i++);
		} else if (nums[i] == 2) {
			swap(nums, --two, i);
		} else {
			i++;
		}
	}
}

private void swap(int[] nums, int i, int j) {
	int k = nums[i];
	nums[i] = nums[j];
	nums[j] = k;
}

341. Flatten Nested List Iterator
Given a nested list of integers, implement an iterator to flatten it.

Each element is either an integer, or a list -- whose elements may also be integers or other lists.

Example 1:
Given the list [[1,1],2,[1,1]],

By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].

Example 2:
Given the list [1,[4,[6]]],

By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].

public abstract class NestedIterator implements Iterator<Integer> {

    private Stack<NestedInteger> mStack;

    public NestedIterator(List<NestedInteger> nestedList) {
        mStack = new Stack<NestedInteger>();
        pushNestedList(nestedList);
    }

    @Override
    public boolean hasNext() {
        while (!mStack.isEmpty()) {
            NestedInteger nest = mStack.peek();
            if (nest.isInteger()) {
                return true;
            } else {
                nest = mStack.pop();
                pushNestedList(nest.getList());
            }
        }
        return false;
    }

    private void pushNestedList(List<NestedInteger> nestedList) {
        for (int i = nestedList.size() - 1; i >= 0; i--) {
            mStack.push(nestedList.get(i));
        }
    }

    @Override
    public Integer next() {
        NestedInteger nest = mStack.pop();
        return nest.getInteger();
    }
}

78. Subsets
Given a set of distinct integers, nums, return all possible subsets.

Note: The solution set must not contain duplicate subsets.

For example,
If nums = [1,2,3], a solution is:

[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

/**
public List<List<Integer>> subsets(int[] nums) {
	List<List<Integer>> result = new LinkedList<List<Integer>>();

	if (nums.length == 0) {
		return result;
	}

	subsets(nums, 0, result, new LinkedList<Integer>());

	return result;
}

private void subsets(int[] nums, int start, List<List<Integer>> list, List<Integer> path) {
	if (start == nums.length) {
		list.add(new LinkedList<Integer>(path));
		return;
	}

	path.add(nums[start]);
	subsets(nums, start + 1, list, path);
	path.remove(path.size() - 1);

	subsets(nums, start + 1, list, path);
}
 */

public List<List<Integer>> subsets(int[] nums) {
	List<List<Integer>> result = new LinkedList<List<Integer>>();

	if (nums.length == 0) {
		return result;
	}

	Arrays.sort(nums);
	subsets(nums, 0, result, new LinkedList<Integer>());
	return result;
}

private void subsets(int[] nums, int start, List<List<Integer>> result, List<Integer> path) {
	result.add(new LinkedList<Integer>(path));
	for (int i = start; i < nums.length; i++) {
		path.add(nums[i]);
		subsets(nums, i + 1, result, path);
		path.remove(path.size() - 1);
	}
}

90. Subsets II
Given a collection of integers that might contain duplicates, nums, return all possible subsets.

Note: The solution set must not contain duplicate subsets.

For example,
If nums = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]

public List<List<Integer>> subsetsWithDup(int[] nums) {
	List<List<Integer>> result = new LinkedList<List<Integer>>();

	if (nums.length == 0) {
		return result;
	}

	subsetsWithDup(nums, 0, result, new LinkedList<Integer>());

	return result;
}

private void subsetsWithDup(int[] nums, int start, List<List<Integer>> list, List<Integer> path) {
	if (start == nums.length) {
		list.add(new LinkedList<Integer>(path));
		return;
	}

	path.add(nums[start]);
	subsetsWithDup(nums, start + 1, list, path);
	path.remove(path.size() - 1);

	// 既然不带当前字符，那后面如果重复的都别带，否则就是带了当前字符的子集
	for ( ; start + 1 < nums.length && nums[start + 1] == nums[start]; start++);
	subsetsWithDup(nums, start + 1, list, path);
}

206. Reverse Linked List
Reverse a singly linked list.

Hint:
A linked list can be reversed either iteratively or recursively. Could you implement both?

// 耗时0ms
public ListNode reverseList(ListNode head) {
	ListNode dummy = new ListNode(0);

	for (ListNode p = head; p != null; ) {
		ListNode next = p.next;
		p.next = dummy.next;
		dummy.next = p;
		p = next;
	}

	return dummy.next;
}

// 耗时30ms，这里耗时是因为要遍历到链表末尾
public ListNode reverseList2(ListNode head) {
	if (head == null) {
		return head;
	}

	if (head.next == null) {
		return head;
	}

	ListNode rev = reverseList2(head.next), p = rev;
	for ( ; p.next != null; p = p.next);
	p.next = head;
	head.next = null;

	return rev;
}

// 耗时1ms
public ListNode reverseList3(ListNode head) {
	ListNode[] nodes = new ListNode[2];
	reverseList3(head, nodes);
	return nodes[0];
}

private void reverseList3(ListNode head, ListNode[] nodes) {
	if (head == null) {
		Arrays.fill(nodes, null);
		return;
	}

	if (head.next == null) {
		Arrays.fill(nodes, head);
		return;
	}

	ListNode[] next = new ListNode[2];
	reverseList3(head.next, next);

	next[1].next = head;
	head.next = null;

	nodes[0] = next[0];
	nodes[1] = head;
}

218. The Skyline Problem




236. Lowest Common Ancestor of a Binary Tree
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”

        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.

// 耗时12ms
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
	if (root == null || root == p || root == q) {
		return root;
	}

	TreeNode left = lowestCommonAncestor(root.left, p, q);
	TreeNode right = lowestCommonAncestor(root.right, p, q);

	if (left == null) {
		return right;
	} else if (right == null) {
		return left;
	} else {
		return root;
	}
}

235. Lowest Common Ancestor of a Binary Search Tree
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”

        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.

// 耗时9ms
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
	if (p.val < root.val && q.val < root.val) {
		return lowestCommonAncestor(root.left, p, q);
	} else if (p.val > root.val && q.val > root.val) {
		return lowestCommonAncestor(root.right, p, q);
	} else {
		return root;
	}
}

98. Validate Binary Search Tree
Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
Example 1:
    2
   / \
  1   3
Binary tree [2,1,3], return true.
Example 2:
    1
   / \
  2   3
Binary tree [1,2,3], return false.

// 耗时1ms
public boolean isValidBST(TreeNode root) {
	return isValidBST(root, (long) Integer.MIN_VALUE - 1, (long) Integer.MAX_VALUE + 1);
}

private boolean isValidBST(TreeNode root, long lower, long upper) {
	if (root == null) {
		return true;
	}
	return root.val > lower && root.val < upper
			&& isValidBST(root.left, lower, root.val)
			&& isValidBST(root.right, root.val, upper);
}

125. Valid Palindrome
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

For example,
"A man, a plan, a canal: Panama" is a palindrome.
"race a car" is not a palindrome.

Note:
Have you consider that the string might be empty? This is a good question to ask during an interview.

For the purpose of this problem, we define empty string as valid palindrome.

// 耗时10ms
public boolean isPalindrome(String s) {
	char[] ss = s.toLowerCase().toCharArray();
	for (int i = 0, j = ss.length - 1; i < j; ) {
		if (!Character.isLetterOrDigit(ss[i])) {
			i++;
		} else if (!Character.isLetterOrDigit(ss[j])) {
			j--;
		} else {
			if (ss[i] != ss[j]) {
				return false;
			} else {
				i++;
				j--;
			}
		}
	}
	return true;
}

43. Multiply Strings
Given two numbers represented as strings, return multiplication of the numbers as a string.

Note:
The numbers can be arbitrarily large and are non-negative.
Converting the input string to integer is NOT allowed.
You should NOT use internal library such as BigInteger.

public String multiply(String num1, String num2) {
	int len1 = num1.length(), len2 = num2.length();
	int[] result = new int[len1 + len2];
	for (int i = len1 - 1; i >= 0; i--) {
		for (int j = len2 - 1; j >= 0; j--) {
			int res = result[i + j + 1] + (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
			result[i + j + 1] = res % 10;
			result[i + j] += res / 10;
		}
	}

	StringBuilder sb = new StringBuilder();
	for (int n : result) {
		// 这里要去掉头部的"0"
		if (n != 0 || sb.length() != 0) {
			sb.append(n);
		}
	}

	// 这里要注意如果是空要返回0
	return sb.length() == 0 ? "0" : sb.toString();
}

133. Clone Graph
Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.


OJ's undirected graph serialization:
Nodes are labeled uniquely.

We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
As an example, consider the serialized graph {0,1,2#1,2#2,2}.

The graph has a total of three nodes, and therefore contains three parts as separated by #.

First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
Second node is labeled as 1. Connect node 1 to node 2.
Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.
Visually, the graph looks like the following:

       1
      / \
     /   \
    0 --- 2
         / \
         \_/
		 
		 
		 
		 
		 
		 
49. Group Anagrams
Given an array of strings, group anagrams together.

For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"], 
Return:

[
  ["ate", "eat","tea"],
  ["nat","tan"],
  ["bat"]
]
Note: All inputs will be in lower-case.

public List<List<String>> groupAnagrams(String[] strs) {
	HashMap<String, List<String>> map = new HashMap<String, List<String>>();
	for (String str : strs) {
		char[] ss = str.toCharArray();
		Arrays.sort(ss);
		String s = new String(ss);

		if (map.containsKey(s)) {
			map.get(s).add(str);
		} else {
			List<String> list = new LinkedList<String>();
			list.add(str);
			map.put(s, list);
		}
	}
	return new LinkedList<List<String>>(map.values());
}

57. Insert Interval
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].

Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].

This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].

public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
	List<Interval> result = new LinkedList<Interval>();

	for (int i = 0; i < intervals.size(); i++) {
		Interval cur = intervals.get(i);
		if (newInterval.start > cur.end) {
			result.add(cur);
		} else if (newInterval.end < cur.start) {
			result.add(newInterval);
			newInterval = cur;
		} else {
			newInterval.start = Math.min(newInterval.start, cur.start);
			newInterval.end = Math.max(newInterval.end, cur.end);
		}
	}

	result.add(newInterval);

	return result;
}

238. Product of Array Except Self
Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Solve it without division and in O(n).

For example, given [1,2,3,4], return [24,12,8,6].

Follow up:
Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)

// 耗时3ms
public int[] productExceptSelf(int[] nums) {
	if (nums.length == 0) {
		return null;
	}

	int left = 1, right = 1;

	int[] result = new int[nums.length];
	Arrays.fill(result, 1);

	for (int i = 0; i < nums.length; i++) {
		result[i] *= left;
		left *= nums[i];
	}

	for (int i = nums.length - 1; i >= 0; i--) {
		result[i] *= right;
		right *= nums[i];
	}

	return result;
}

38. Count and Say
The count-and-say sequence is the sequence of integers beginning as follows:
1, 11, 21, 1211, 111221, ...

1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.
Given an integer n, generate the nth sequence.

Note: The sequence of integers will be represented as a string.

public String countAndSay(int n) {
	String s = "1";
	for (int i = 2; i <= n; i++) {
		s = next(s);
	}
	return s;
}

private String next(String s) {
	StringBuilder sb = new StringBuilder();

	char cur = 0;
	int times = 0;

	for (int i = 0; i < s.length(); i++) {
		if (times == 0) {
			cur = s.charAt(i);
			times = 1;
		} else if (s.charAt(i) == cur) {
			times++;
		} else {
			sb.append(String.format("%d%c", times, cur));
			cur = s.charAt(i);
			times = 1;
		}
	}

	// 这一句千万别掉了
	if (times != 0) {
		sb.append(String.format("%d%c", times, cur));
	}

	return sb.toString();
}

209. Minimum Size Subarray Sum
Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn't one, return 0 instead.

For example, given the array [2,3,1,2,4,3] and s = 7,
the subarray [4,3] has the minimal length under the problem constraint.

click to show more practice.

More practice:
If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).

public int minSubArrayLen(int s, int[] nums) {
	int min = Integer.MAX_VALUE;
	for (int i = 0, j = 0, sum = 0; i < nums.length; i++) {
		sum += nums[i];
		if (sum >= s) {
			for ( ; j < i && sum - nums[j] >= s; sum -= nums[j], j++);
			min = Math.min(min, i - j + 1);
		}
	}
	return min == Integer.MAX_VALUE ? 0 : min;
}

39. Combination Sum
Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

The same repeated number may be chosen from C unlimited number of times.

Note:
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
For example, given candidate set [2, 3, 6, 7] and target 7, 
A solution set is: 
[
  [7],
  [2, 2, 3]
]

// 这题关键在于去重
public List<List<Integer>> combinationSum(int[] candidates, int target) {
	List<List<Integer>> result = new LinkedList<List<Integer>>();
	Arrays.sort(candidates);
	dfs(candidates, 0, target, result, new LinkedList<Integer>());
	return result;
}

private void dfs(int[] candidates, int start, int target, List<List<Integer>> result, List<Integer> path) {
	if (target < 0) {
		return;
	}

	if (target == 0) {
		result.add(new LinkedList<Integer>(path));
		return;
	}

	for (int i = start; i < candidates.length; i++) {
		if (i > start && candidates[i] == candidates[i - 1]) {
			continue;
		}
		path.add(candidates[i]);
		dfs(candidates, i, target - candidates[i], result, path);
		path.remove(path.size() - 1);
	}
}

40. Combination Sum II
Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

Each number in C may only be used once in the combination.

Note:
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, 
A solution set is: 
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
	List<List<Integer>> result = new LinkedList<List<Integer>>();
	Arrays.sort(candidates);
	dfs(candidates, 0, target, result, new LinkedList<Integer>());
	return result;
}

private void dfs(int[] candidates, int start, int target, List<List<Integer>> result, List<Integer> path) {
	if (target < 0) {
		return;
	}

	if (target == 0) {
		result.add(new LinkedList<Integer>(path));
		return;
	}

	for (int i = start; i < candidates.length; i++) {
		if (i > start && candidates[i] == candidates[i - 1]) {
			continue;
		}

		path.add(candidates[i]);

		// 关键是这里变成i + 1
		dfs(candidates, i + 1, target - candidates[i], result, path);
		path.remove(path.size() - 1);
	}
}

216. Combination Sum III
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.


Example 1:

Input: k = 3, n = 7

Output:

[[1,2,4]]

Example 2:

Input: k = 3, n = 9

Output:

[[1,2,6], [1,3,5], [2,3,4]]

public List<List<Integer>> combinationSum3(int k, int n) {
	List<List<Integer>> result = new LinkedList<List<Integer>>();
	dfs(k, n, 1, result, new LinkedList<Integer>());
	return result;
}

private void dfs(int k, int n, int start, List<List<Integer>> result, List<Integer> path) {
	if (k == 0 && n == 0) {
		result.add(new LinkedList<Integer>(path));
		return;
	}

	if (n < 0 || k < 0 || start > 9) {
		return;
	}

	for (int i = start; i <= 9; i++) {
		path.add(i);
		dfs(k - 1, n - i, i + 1, result, path);
		path.remove(path.size() - 1);
	}
}

377. Combination Sum IV
Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.

Example:

nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
Follow up:
What if negative numbers are allowed in the given array?
How does it change the problem?
What limitation we need to add to the question to allow negative numbers?

public int combinationSum4(int[] nums, int target) {
	int[] dp = new int[target + 1];
	// 这里排序便于之后break
	Arrays.sort(nums);
	// 这里0为什么是1呢，我开始也不解，其实就是说如果组合中带的刚好是当前数，那么组合数只有1种。比如target为3的时候，遍历到了nums中的3，那么只有1种可能。target为2的时候，遍历到了nums中的2，也只有一种可能
	dp[0] = 1;
	for (int i = 1; i <= target; i++) {
		for (int num : nums) {
			if (num > i) {
				break;
			} else {
				dp[i] += dp[i - num];
			}
		}
	}
	return dp[target];
}

380. Insert Delete GetRandom O(1)
Design a data structure that supports all following operations in average O(1) time.

insert(val): Inserts an item val to the set if not already present.
remove(val): Removes an item val from the set if present.
getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.
Example:

// Init an empty set.
RandomizedSet randomSet = new RandomizedSet();

// Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomSet.insert(1);

// Returns false as 2 does not exist in the set.
randomSet.remove(2);

// Inserts 2 to the set, returns true. Set now contains [1,2].
randomSet.insert(2);

// getRandom should return either 1 or 2 randomly.
randomSet.getRandom();

// Removes 1 from the set, returns true. Set now contains [2].
randomSet.remove(1);

// 2 was already in the set, so return false.
randomSet.insert(2);

// Since 1 is the only number in the set, getRandom always return 1.
randomSet.getRandom();

// 耗时111ms
public class RandomizedSet {

    private HashMap<Integer, Integer> mMap;
    private List<Integer> mList;
    private Random mRandom;

    public RandomizedSet() {
        mList = new ArrayList<Integer>();
        mMap = new HashMap<Integer, Integer>();
        mRandom = new Random();
    }

    public boolean insert(int val) {
        if (mMap.containsKey(val)) {
            return false;
        }
        mList.add(val);
        mMap.put(val, mList.size() - 1);
        return true;
    }

    public boolean remove(int val) {
        if (!mMap.containsKey(val)) {
            return false;
        }
        int index = mMap.remove(val);
        int lastIndex = mList.size() - 1;
        if (index != lastIndex) {
            int lastVal = mList.get(lastIndex);
            mList.set(index, lastVal);
            // 这里要注意重新设置lastVal的index
            mMap.put(lastVal, index);
        }
        mList.remove(lastIndex);
        return true;
    }

    public int getRandom() {
        int index = mRandom.nextInt(mList.size());
        return mList.get(index);
    }
}

79. Word Search
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

For example,
Given board =

[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED", -> returns true,
word = "SEE", -> returns true,
word = "ABCB", -> returns false.

// 耗时9ms
public boolean exist(char[][] board, String word) {
	if (board.length == 0) {
		return false;
	}

	int row = board.length, col = board[0].length;
	for (int i = 0; i < row; i++) {
		for (int j = 0; j < col; j++) {
			if (dfs(board, i, j, word, 0)) {
				return true;
			}
		}
	}

	return false;
}

private boolean dfs(char[][] board, int x, int y, String word, int start) {
	if (start >= word.length()) {
		return true;
	}

	if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) {
		return false;
	}

	char c = board[x][y];

	if (c != word.charAt(start)) {
		return false;
	}

	// 这里为了避免重复访问
	board[x][y] = '#';
	boolean flag = dfs(board, x + 1, y, word, start + 1)
			|| dfs(board, x - 1, y, word, start + 1)
			|| dfs(board, x, y + 1, word, start + 1)
			|| dfs(board, x, y - 1, word, start + 1);
	board[x][y] = c;

	return flag;
}

212. Word Search II
Given a 2D board and a list of words from the dictionary, find all words in the board.

Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

For example,
Given words = ["oath","pea","eat","rain"] and board =

[
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
Return ["eat","oath"].
Note:
You may assume that all inputs are consist of lowercase letters a-z.

click to show hint.

You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?

If the current candidate does not exist in all words' prefix, you could stop backtracking immediately. What kind of data structure could answer such query efficiently? Does a hash table work? Why or why not? How about a Trie? If you would like to learn how to implement a basic trie, please work on this problem: Implement Trie (Prefix Tree) first.

public List<String> findWords(char[][] board, String[] words) {
    int row = board.length;
    int col = board[0].length;

    TrieNode root = new TrieNode();

    for (String word : words) {
        buildTrie(word, root);
    }

    List<String> result = new ArrayList<String>();

    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; j++) {
            dfs(board, i, j, root, result);
        }
    }

    return result;
}

private void dfs(char[][] board, int i, int j, TrieNode node, List<String> result) {
    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length) {
        return;
    }

    char c = board[i][j];

    if (c < 'a' || c > 'z') {
        return;
    }

    node = node.next[c - 'a'];

    if (node == null) {
        return;
    }

    if (node.word != null) {
        result.add(node.word);
        node.word = null;
    }

    board[i][j] = '#';
    dfs(board, i + 1, j, node, result);
    dfs(board, i - 1, j, node, result);
    dfs(board, i, j + 1, node, result);
    dfs(board, i, j - 1, node, result);
    board[i][j] = '#';
}

private void buildTrie(String word, TrieNode root) {
    char[] arr = word.toCharArray();
    for (char c : arr) {
        if (root.next[c - 'a'] == null) {
            root.next[c - 'a'] = new TrieNode();
        }
        root = root.next[c - 'a'];
    }
    root.word = word;
}

private class TrieNode {
    TrieNode[] next = new TrieNode[26];
    String word;
}

71. Simplify Path
Given an absolute path for a file (Unix-style), simplify it.

For example,
path = "/home/", => "/home"
path = "/a/./b/../../c/", => "/c"

Corner Cases:
Did you consider the case where path = "/../"?
In this case, you should return "/".
Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".
In this case, you should ignore redundant slashes and return "/home/foo".

public String simplifyPath(String path) {
	Deque<String> queue = new LinkedList<>();
	String[] strs = path.split("/");
	for (String str : strs) {
		if (str.equals("..")) {
			if (!queue.isEmpty()) {
				queue.pollLast();
			}
		} else if (!str.isEmpty() && !str.equals(".")) {
			queue.offerLast(str);
		}
	}

	StringBuilder sb = new StringBuilder();
	while (!queue.isEmpty()) {
		sb.append(String.format("/%s", queue.poll()));
	}
	return sb.length() == 0 ? "/" : sb.toString();
}

13. Roman to Integer
Given a roman numeral, convert it to an integer.

Input is guaranteed to be within the range from 1 to 3999.

public int romanToInt(String s) {
    int len = s.length();

    int n = 0;

    for (int i = len - 1; i >= 0; i--) {
        char c = s.charAt(i);

        switch (c) {
            case 'V': n += 5; break;
            case 'L': n += 50; break;
            case 'D': n += 500; break;
            case 'I': n += (n >= 5 ? -1 : 1); break;
            case 'X': n += (n >= 50 ? -10 : 10); break;
            case 'C': n += (n >= 500 ? -100 : 100); break;
            case 'M': n += 1000; break;
        }
    }

    return n;
}

12. Integer to Roman
Given an integer, convert it to a roman numeral.

Input is guaranteed to be within the range from 1 to 3999.

String intToRoman(int num) {
	String[] K1000 = { "", "M", "MM", "MMM" };
    String[] K100 = { "", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM" };
    String[] K10 = { "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC" };
    String[] K1 = { "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX" };

    StringBuilder sb = new StringBuilder();
    sb.append(K1000[num / 1000]);
    sb.append(K100[(num / 100) % 10]);
    sb.append(K10[(num / 10) % 10]);
    sb.append(K1[num % 10]);
    return sb.toString();
}

215. Kth Largest Element in an Array
Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

For example,
Given [3,2,1,5,6,4] and k = 2, return 5.

Note: 
You may assume k is always valid, 1 ≤ k ≤ array's length.

// 耗时16ms，时间复杂度O(nlgn)，空间复杂度O(n)
// 按降序排的，出队列k次获取第k大的数
public int findKthLargest(int[] nums, int k) {
	Queue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>() {
		@Override
		public int compare(Integer o1, Integer o2) {
			return o1 > o2 ? -1 : 1;
		}
	});

	for (int n : nums) {
		queue.add(n);
	}

	int num = 0;

	for (int i = 0; i < k; i++) {
		num = queue.poll();
	}

	return num;
}

// 耗时17ms，时间复杂度O(nlgk)，空间复杂度O(k)
// 按升序排的，最后队列头是最后的k个数中最小的，也就是全局第k大的
public int findKthLargest2(int[] nums, int k) {
	Queue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>() {
		@Override
		public int compare(Integer o1, Integer o2) {
			return o1 > o2 ? 1 : -1;
		}
	});

	for (int n : nums) {
		queue.add(n);

		if (queue.size() > k) {
			queue.poll();
		}
	}

	return queue.peek();
}

// 耗时3ms，时间复杂度O(nlgn)，空间复杂度O(l)
public int findKthLargest3(int[] nums, int k) {
	Arrays.sort(nums);
	return nums[nums.length - k];
}

// 快速选择，平均时间复杂度为O(n)
// T(n) = T(n / 2) + n = O(n)
// 对比快速排序T(n) = 2T(n / 2) + n = O(nlgn)
// 区别在于这个被pivot分隔后，只用处理其中的一半，而快排两边都要处理
// 耗时18ms
public int findKthLargest4(int[] nums, int k) {
	return nums[findKthLargest4(nums, 0, nums.length - 1, k)];
}

public int findKthLargest4(int[] nums, int start, int end, int k) {
	int pivot = partition(nums, start, end);

	int rank = end - pivot + 1;

	if (rank == k) {
		return pivot;
	} else if (rank > k) {
		return findKthLargest4(nums, pivot + 1, end, k);
	} else {
		return findKthLargest4(nums, start, pivot - 1, k - rank);
	}
}

public int partition(int[] nums, int start, int end) {
	int pivot = nums[end], left = start;

	for (int i = start; i < end; i++) {
		if (nums[i] <= pivot) {
			swap(nums, left++, i);
		}
	}

	swap(nums, left, end);

	return left;
}

private void swap(int[] nums, int left, int right) {
	int t = nums[left];
	nums[left] = nums[right];
	nums[right] = t;
}

398. Random Pick Index
Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.

Note:
The array size can be very large. Solution that uses too much extra space will not pass the judge.

Example:

int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);

// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
solution.pick(3);

// pick(1) should return 0. Since in the array only nums[0] is equal to 1.
solution.pick(1);

public class RandomPickIndex {

    private Random mRandom;
    private int[] mNums;

    public RandomPickIndex(int[] nums) {
        mRandom = new Random();
        mNums = nums;
    }

    public int pick(int target) {
        int count = 0;

        int result = -1;

        for (int i = 0; i < mNums.length; i++) {
            if (mNums[i] == target && mRandom.nextInt(++count) == 0) {
                result = i;
            }
        }

        return result;
    }
}

128. Longest Consecutive Sequence
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

For example,
Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.

Your algorithm should run in O(n) complexity.

public int longestConsecutive(int[] nums) {
	HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();

	int res = 0;

	for (int i = 0; i < nums.length; i++) {
		int n = nums[i];

		if (!map.containsKey(n)) {
			int left = map.containsKey(n - 1) ? map.get(n - 1) : 0;
			int right = map.containsKey(n + 1) ? map.get(n + 1) : 0;
			int len = left + right + 1;

			// 这句一定不能掉，因为map会查重的，如果这里n没丢到map里，后面再出现重复的n会被覆盖
			map.put(n, len);

			res = Math.max(res, len);

			map.put(n - left, len);
			map.put(n + right, len);
		}
	}

	return res;
}

146. LRU Cache
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

public class LRUCache {

    private int mCapacity;

    private Map<Integer, DNode> mMap;

    private DNode mHead;

    public LRUCache(int capacity) {
        mCapacity = capacity;
        mMap = new HashMap<Integer, DNode>();

        mHead = new DNode();
        mHead.prev = mHead;
        mHead.next = mHead;
    }

    public int get(Integer key) {
        System.out.println(String.format("get %d", key));
        if (!mMap.containsKey(key)) {
            return -1;
        }

        DNode node = mMap.get(key);
        node.remove();
        node.addAfter(mHead);
        return node.val;
    }

    public void set(Integer key, int value) {
        System.out.println(String.format("set %d %d", key, value));

        if (mMap.containsKey(key)) {
            DNode node = mMap.get(key);
            node.val = value;

            node.remove();
            node.addAfter(mHead);
        } else {
            DNode node = new DNode(key, value);
            mMap.put(key, node);
            node.addAfter(mHead);

            if (mMap.size() > mCapacity) {
                DNode old = mHead.prev;
                mMap.remove(old.key);
                old.remove();
            }
        }
    }
}

class DNode {
    DNode prev, next;
    int key, val;

    DNode() {

    }

    DNode(int key, int val) {
        this.key = key;
        this.val = val;
    }

    void remove() {
        prev.next = next;
        next.prev = prev;
    }

    void addAfter(DNode node) {
        next = node.next;
        node.next.prev = this;

        prev = node;
        node.next = this;
    }
}

/*
public class LRUCache {
    private Map<Integer, Integer> mMap;

    private int mCapacity;

    public LRUCache(int capacity) {
        mCapacity = capacity;

        // 第三个参数true表示用accessOrder排序
        mMap = new LinkedHashMap<Integer, Integer>(mCapacity, 0.5f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
                return mMap.size() > mCapacity;
            }
        };
    }

    // 这里不能直接返回get(key)，可能会抛NPR
    public int get(Integer key) {
        if (mMap.containsKey(key)) {
            return mMap.get(key);
        } else {
            return -1;
        }
    }

    public void set(Integer key, int value) {
        mMap.put(key, value);
    }
}
*/

28. Implement strStr()
Implement strStr().

Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

// 这里非常重要的是i<=len1-len2，如果没有这个会超时
int strStr(String haystack, String needle) {
	char[] s = haystack.toCharArray();
	char[] t = needle.toCharArray();
	int l1 = s.length, l2 = t.length;
	for (int i = 0, j = 0; i <= l1 - l2; i++) {
		for (j = 0; j < l2 && s[i + j] == t[j]; j++);
		if (j == l2) {
			return i;
		}
	}
	return -1;
}

public int strStr2(String haystack, String needle) {
	int l1 = haystack.length(), l2 = needle.length();
	if (l1 < l2) {
		return -1;
	} else if (l2 == 0) {
		return 0;
	}
	int threshold = l1 - l2;
	for (int i = 0; i <= threshold; ++i) {
		if (haystack.substring(i,i+l2).equals(needle)) {
			return i;
		}
	}
	return -1;
}

208. Implement Trie (Prefix Tree)
Implement a trie with insert, search, and startsWith methods.

Note:
You may assume that all inputs are consist of lowercase letters a-z.

public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    public void insert(String word) {
        char[] s = word.toCharArray();
        TrieNode node = root;
        for (char c : s) {
            if (node.nexts[c - 'a'] == null) {
                node.nexts[c - 'a'] = new TrieNode();
            }
            node = node.nexts[c - 'a'];
        }
        node.word = word;
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
        char[] s = word.toCharArray();
        TrieNode node = root;
        for (char c : s) {
            if (node.nexts[c - 'a'] == null) {
                return false;
            } else {
                node = node.nexts[c - 'a'];
            }
        }
        return node.word != null;
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
        char[] s = prefix.toCharArray();
        TrieNode node = root;
        for (char c : s) {
            if (node.nexts[c - 'a'] == null) {
                return false;
            } else {
                node = node.nexts[c - 'a'];
            }
        }
        return true;
    }

    class TrieNode {

        TrieNode[] nexts = new TrieNode[26];
        String word;

        // Initialize your data structure here.
        public TrieNode() {

        }
    }
}

33. Search in Rotated Sorted Array
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

public int search(int[] nums, int target) {
	int left = 0, right = nums.length - 1;

	// 注意这里的等号
	while (left <= right) {
		int mid = left + ((right - left) >>> 1);

		if (target == nums[mid]) {
			return mid;
		}

		// 注意这里的等号
		// 先确定单调区间，然后判断target是不是在单调区间内，如果不在就在另一半区间
		if (nums[mid] >= nums[left]) {
			if (target >= nums[left] && target < nums[mid]) {
				right = mid - 1;
			} else {
				left = mid + 1;
			}
		} else if (nums[mid] < nums[right]) {
			if (target > nums[mid] && target <= nums[right]) {
				left = mid + 1;
			} else {
				right = mid - 1;
			}
		}
	}

	return -1;
}

81. Search in Rotated Sorted Array II
Follow up for "Search in Rotated Sorted Array":
What if duplicates are allowed?

Would this affect the run-time complexity? How and why?

Write a function to determine if a given target is in the array.

public int search(int[] nums, int target) {
	int left = 0, right = nums.length - 1;

	// 注意这里的等号
	while (left <= right) {
		int mid = left + ((right - left) >>> 1);

		if (target == nums[mid]) {
			return mid;
		}

		// 注意这里的等号
		// 先确定单调区间，然后判断target是不是在单调区间内，如果不在就在另一半区间
		if (nums[mid] > nums[left]) {
			if (target >= nums[left] && target < nums[mid]) {
				right = mid - 1;
			} else {
				left = mid + 1;
			}
		} else if (nums[mid] == nums[left]) {
			// nums[mid]==nums[left]有两种情况，在不好确定哪种情况时，left++可以进一步缩小范围
			left++;
		} else {
			// 这里可以肯定nums[mid]<nums[left]，所以mid肯定在拐点右边，换言之右边是单调的
			if (target > nums[mid] && target <= nums[right]) {
				left = mid + 1;
			} else {
				right = mid - 1;
			}
		}
	}

	return -1;
}

153. Find Minimum in Rotated Sorted Array
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

You may assume no duplicate exists in the array.

public int findMin(int[] nums) {
    for (int left = 0, right = nums.length - 1; left >= 0 && left <= right; ) {
        if (nums[right] > nums[left]) {
            return nums[left];
        }
        int mid = left + ((right - left) >> 1);
        
        if (nums[mid] > nums[left]) {
            left = mid + 1;
        } else if (nums[mid] < nums[right]) {
            right = mid;
        } else {
            return Math.min(nums[left], nums[right]);
        }
    }
    return 0;
}

154. Find Minimum in Rotated Sorted Array II
Follow up for "Find Minimum in Rotated Sorted Array":
What if duplicates are allowed?

Would this affect the run-time complexity? How and why?
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

The array may contain duplicates.

public int findMin(int[] nums) {
    int left = 0, right = nums.length - 1;
    
    for ( ; left < right; ) {
        int mid = left + ((right - left) >> 1);
        
        if (nums[right] > nums[left]) {
            return nums[left];
        } 
        
        if (nums[mid] > nums[left]) {
            left = mid + 1;
        } else if (nums[mid] < nums[right]) {
            right = mid;
        } else {
            left++;
        }
    }
    
    return nums[left];
}

88. Merge Sorted Array
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.

public void merge(int[] nums1, int m, int[] nums2, int n) {
	int j = m - 1, k = n - 1;
	for (int i = m + n - 1; i >= 0; i--) {
		if (j < 0) {
			nums1[i] = nums2[k--];
		} else if (k < 0) {
			nums1[i] = nums1[j--];
		} else {
			if (nums1[j] >= nums2[k]) {
				nums1[i] = nums1[j--];
			} else {
				nums1[i] = nums2[k--];
			}
		}
	}
}

127. Word Ladder
Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:

Only one letter can be changed at a time
Each intermediate word must exist in the word list
For example,

Given:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]
As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.

Note:
Return 0 if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.

 // 常规的BFS，耗时141ms
public int ladderLength(String beginWord, String endWord, Set<String> wordList) {
	Queue<String> queue = new LinkedList<String>();
	Queue<String> next = new LinkedList<String>();
	queue.add(beginWord);

	int length = 0;

	while (!queue.isEmpty()) {
		String s = queue.poll();
		char[] ss = s.toCharArray();

		for (int i = 0; i < ss.length; i++) {
			char c = ss[i];
			for (int j = 0; j < 26; j++) {
				ss[i] = (char) ('a' + j);
				if (ss[i] == c) {
					continue;
				}
				String t = new String(ss);

				if (t.equals(endWord)) {
					return length + 2;
				}

				if (wordList.remove(t)) {
					next.add(t);
				}
			}
			ss[i] = c;
		}

		if (queue.isEmpty()) {
			Queue<String> t = queue;
			queue = next;
			next = t;
			length++;
		}
	}

	return 0;
}

// 采用双端BFS，耗时28ms
// 假设每层分叉因子为k，一共n层，则BFS时间复杂度为O(k^n)，双端BFS时间复杂度为O(2 * k^(n / 2))，显然要快得多
public int ladderLength2(String beginWord, String endWord, Set<String> wordList) {
	Set<String> beginSet = new HashSet<>();
	beginSet.add(beginWord);

	Set<String> endSet = new HashSet<String>();
	endSet.add(endWord);

	int length = 1;

	while (!beginSet.isEmpty() && !endSet.isEmpty()) {
		if (beginSet.size() > endSet.size()) {
			Set<String> temp = beginSet;
			beginSet = endSet;
			endSet = temp;
		}

		Set<String> nextSet = new HashSet<String>();

		for (String word : beginSet) {
			char[] wordArr = word.toCharArray();

			for (int i = 0; i < wordArr.length; i++) {
				char c = wordArr[i];

				for (int j = 0; j < 26; j++) {
					if ('a' + j == c) {
						continue;
					}
					wordArr[i] = (char) ('a' + j);
					String s = String.valueOf(wordArr);

					if (endSet.contains(s)) {
						return length + 1;
					}

					if (wordList.contains(s)) {
						nextSet.add(s);
						wordList.remove(s);
					}
				}

				wordArr[i] = c;
			}
		}

		beginSet = nextSet;
		length++;
	}

	return 0;
}

126. Word Ladder II
Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:

Only one letter can be changed at a time
Each intermediate word must exist in the word list
For example,

Given:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]
Return
  [
    ["hit","hot","dot","dog","cog"],
    ["hit","hot","lot","log","cog"]
  ]
Note:
All words have the same length.
All words contain only lowercase alphabetic characters.




334. Increasing Triplet Subsequence
Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.

Formally the function should:
Return true if there exists i, j, k 
such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false.
Your algorithm should run in O(n) time complexity and O(1) space complexity.

Examples:
Given [1, 2, 3, 4, 5],
return true.

Given [5, 4, 3, 2, 1],
return false.

public boolean increasingTriplet(int[] nums) {
	int first = Integer.MAX_VALUE, second = Integer.MAX_VALUE;

	for (int i = 0; i < nums.length; i++) {
		if (nums[i] <= first) {
			first = nums[i];
		} else if (nums[i] <= second) {
			second = nums[i];
		} else {
			return true;
		}
	}

	return false;
}

50. Pow(x, n)
Implement pow(x, n).

public double myPow(double x, int n) {
	if (n == 0) {
		return 1;
	}

	long nn = n;
	if (nn < 0) {
		x = 1 / x;
		nn = -nn;
	}
	double y = myPow(x, (int) (nn / 2));

	if (nn % 2 == 0) {
		return y * y;
	} else {
		return y * y * x;
	}
}

286. Walls and Gates
You are given a m x n 2D grid initialized with these three possible values.

-1 - A wall or an obstacle.
0 - A gate.
INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.
Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.

For example, given the 2D grid:
INF  -1  0  INF
INF INF INF  -1
INF  -1 INF  -1
  0  -1 INF INF
After running your function, the 2D grid should be:
  3  -1   0   1
  2   2   1  -1
  1  -1   2  -1
  0  -1   3   4
Show Company Tags
Show Tags
Show Similar Problems

// 耗时7ms
public void wallsAndGates(int[][] rooms) {
	if (rooms.length == 0) {
		return;
	}
	int row = rooms.length, col = rooms[0].length;
	for (int i = 0; i < row; i++) {
		for (int j = 0; j < col; j++) {
			if (rooms[i][j] == 0) {
				dfs(rooms, i, j, 0);
			}
		}
	}
}

private void dfs(int[][] rooms, int i, int j, int dis) {
	if (i < 0 || i >= rooms.length || j < 0 || j >= rooms[0].length) {
		return;
	}

	// 这个条件非常重要
	// 如果rooms[i][j]=0,dis=0，则这里可以继续走下去
	// 如果rooms[i][j]=0,dis!=0，则这里直接跳过，表示遇到另一个0了，那个门的情况我们不处理
	// 如果room[i][j]!=0,dis!=0,但是rooms[i][j]<dis，有两种情况，
	//      1. 一种是在当前dfs中该节点被访问过了，所以值会比dis小，这种情况下就别重复访问了
	//      2. 另一种是当前dfs没访问过，但是在另一个dfs中访问过了，该节点离另一个门比较近，所以这个节点会绕过，虽然这个节点
	// 的邻居节点本次没有访问，但是仍然会通过其他的路径访问到的，所以这里直接return没有影响。
	if (rooms[i][j] < dis) {
		return;
	}

	rooms[i][j] = dis;

	dfs(rooms, i + 1, j, dis + 1);
	dfs(rooms, i - 1, j, dis + 1);
	dfs(rooms, i, j + 1, dis + 1);
	dfs(rooms, i, j - 1, dis + 1);
}

// 耗时19ms
public void wallsAndGates2(int[][] rooms) {
	if (rooms.length == 0 || rooms[0].length == 0) return;
	Queue<int[]> queue = new LinkedList<>();
	for (int i = 0; i < rooms.length; i++) {
		for (int j = 0; j < rooms[0].length; j++) {
			if (rooms[i][j] == 0) queue.add(new int[]{i, j});
		}
	}
	while (!queue.isEmpty()) {
		int[] top = queue.remove();
		int row = top[0], col = top[1];
		if (row > 0 && rooms[row - 1][col] == Integer.MAX_VALUE) {
			rooms[row - 1][col] = rooms[row][col] + 1;
			queue.add(new int[]{row - 1, col});
		}
		if (row < rooms.length - 1 && rooms[row + 1][col] == Integer.MAX_VALUE) {
			rooms[row + 1][col] = rooms[row][col] + 1;
			queue.add(new int[]{row + 1, col});
		}
		if (col > 0 && rooms[row][col - 1] == Integer.MAX_VALUE) {
			rooms[row][col - 1] = rooms[row][col] + 1;
			queue.add(new int[]{row, col - 1});
		}
		if (col < rooms[0].length - 1 && rooms[row][col + 1] == Integer.MAX_VALUE) {
			rooms[row][col + 1] = rooms[row][col] + 1;
			queue.add(new int[]{row, col + 1});
		}
	}
}

69. Sqrt(x)
Implement int sqrt(int x).

Compute and return the square root of x.

public int mySqrt(int x) {
	int left = 1, right = x;

	while (left <= right) {
		int mid = left + ((right - left) >>> 1);

		int y = x / mid;

		if (mid < y) {
			left = mid + 1;
		} else if (mid > y) {
			right = mid - 1;
		} else {
			return mid;
		}
	}

	return right;
}

102. Binary Tree Level Order Traversal
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]

// 耗时2ms
public List<List<Integer>> levelOrder(TreeNode root) {
	List<List<Integer>> result = new LinkedList<List<Integer>>();

	if (root == null) {
		return result;
	}

	Queue<TreeNode> queue = new LinkedList<TreeNode>();
	Queue<TreeNode> next = new LinkedList<TreeNode>();
	queue.add(root);

	List<Integer> cur = null;

	while (!queue.isEmpty()) {
		TreeNode node = queue.poll();

		if (cur == null) {
			cur = new LinkedList<Integer>();
			result.add(cur);
		}

		cur.add(node.val);

		if (node.left != null) {
			next.add(node.left);
		}

		if (node.right != null) {
			next.add(node.right);
		}

		if (queue.isEmpty()) {
			Queue<TreeNode> temp = queue;
			queue = next;
			next = temp;
			cur = null; // 注意这里要置空
		}
	}

	return result;
}

20. Valid Parentheses
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

// 耗时5ms
public boolean isValid(String s) {
	char[] ss = s.toCharArray();

	char[] stack = new char[ss.length];
	int top = -1;

	for (char c : ss) {
		if ("{([".indexOf(c) >= 0) {
			stack[++top] = c;
			continue;
		}

		switch (c) {
			case ')':
				if (top < 0 || stack[top--] != '(') {
					return false;
				}
				break;

			case '}':
				if (top < 0 || stack[top--] != '{') {
					return false;
				}
				break;

			case ']':
				if (top < 0 || stack[top--] != '[') {
					return false;
				}
				break;
		}
	}

	return top < 0;
}

269. Alien Dictionary
There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.

For example,
Given the following words in dictionary,

[
  "wrt",
  "wrf",
  "er",
  "ett",
  "rftt"
]
The correct order is: "wertf".

Note:
You may assume all letters are in lowercase.
If the order is invalid, return an empty string.
There may be multiple valid order of letters, return any one of them is fine.



68. Text Justification
Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.

For example,
words: ["This", "is", "an", "example", "of", "text", "justification."]
L: 16.

Return the formatted lines as:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
Note: Each word is guaranteed not to exceed L in length.

Corner Cases:
A line other than the last line might contain only one word. What should you do in this case?
In this case, that line should be left-justified.




221. Maximal Square
Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.

For example, given the following matrix:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
Return 4.

public int maximalSquare(char[][] matrix) {
	if (matrix == null || matrix.length == 0) {
		return 0;
	}

	int row = matrix.length;
	int col = matrix[0].length;

	int[][] f = new int[row][col];

	int max = 0;

	for (int i = 0; i < col; i++) {
		f[0][i] = matrix[0][i] == '1' ? 1 : 0;
		max = Math.max(max, f[0][i]);
	}

	for (int i = 0; i < row; i++) {
		f[i][0] = matrix[i][0] == '1' ? 1 : 0;
		max = Math.max(max, f[i][0]);
	}

	for (int i = 1; i < row; i++) {
		for (int j = 1; j < col; j++) {
			if (matrix[i][j] == '0') {
				f[i][j] = 0;
			} else {
				int mn = Math.min(f[i - 1][j], f[i][j - 1]);
				f[i][j] = Math.min(mn, f[i - 1][j - 1]) + 1;
				max = Math.max(max, f[i][j]);
			}
		}
	}

	return max * max;
}

274. H-Index
Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.

According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each."

For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.

Note: If there are several possible values for h, the maximum one is taken as the h-index.

Hint:

An easy approach is to sort the array first.
What are the possible values of h-index?
A faster approach is to use extra space.

// 耗时4ms，时间复杂度O(nlgn)，因为这里有排序
public int hIndex(int[] citations) {
	Arrays.sort(citations);

	int citation = 0;
	for (int i = citations.length - 1; i >= 0; i--) {
		int min = Math.min(citations.length - i, citations[i]);
		citation = Math.max(min, citation);
	}

	return citation;
}

// 耗时1ms，时间复杂度O(n)
public int hIndex2(int[] citations) {
	int len = citations.length;

	int[] f = new int[len + 1];
	for (int n : citations) {
		if (n >= len) {
			f[len]++;
		} else {
			f[n]++;
		}
	}

	for (int i = len, j = 0; i >= 0; i--) {
		j += f[i];
		if (j >= i) {
			return i;
		}
	}

	return 0;
}

275. H-Index II
Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?

Hint:

Expected runtime complexity is in O(log n) and the input is sorted.

// 1 100
public int hIndex(int[] citations) {
	int len = citations.length, left = 0, right = len - 1;

	while (left <= right) {
		int mid = left + ((right - left) >>> 1);

		int articles = len - mid;

		if (articles == citations[mid]) {
			// 这是临界点，再往下文章数会大于引用
			return articles;
		} else if (articles > citations[mid]) {
			// 文章数大于引用，继续往下走
			left = mid + 1;
		} else {
			// 文章数小于引用，继续往前走
			right = mid - 1;
		}
	}

	return len - left;
}

116. Populating Next Right Pointers in Each Node
Given a binary tree

    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    }
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Note:

You may only use constant extra space.
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).
For example,
Given the following perfect binary tree,
         1
       /  \
      2    3
     / \  / \
    4  5  6  7
After calling your function, the tree should look like:
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \  / \
    4->5->6->7 -> NULL
	
public void connect(TreeLinkNode root) {
	for ( ; root != null; root = root.left) {
		TreeLinkNode dummy = new TreeLinkNode(0), cur = dummy;
		for (TreeLinkNode node = root; node != null && node.left != null && node.right != null; node = node.next) {
			cur.next = node.left;
			cur.next.next = node.right;
			cur = cur.next.next;
		}
		cur.next = null;
	}
}	
	
	
117. Populating Next Right Pointers in Each Node II
Follow up for problem "Populating Next Right Pointers in Each Node".

What if the given tree could be any binary tree? Would your previous solution still work?

Note:

You may only use constant extra space.
For example,
Given the following binary tree,
         1
       /  \
      2    3
     / \    \
    4   5    7
After calling your function, the tree should look like:
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \    \
    4-> 5 -> 7 -> NULL
	
public void connect(TreeLinkNode root) {
	TreeLinkNode dummy = new TreeLinkNode(0);

	// 注意下次循环的起始条件为dummy.next，而不是root.left或root.right，不确定是否为null
	for ( ; root != null; root = dummy.next) {
		TreeLinkNode cur = dummy;
		for (TreeLinkNode node = root; node != null; node = node.next) {
			if (node.left != null) {
				cur.next = node.left;
				cur = cur.next;
			}

			if (node.right != null) {
				cur.next = node.right;
				cur = cur.next;
			}
		}
		cur.next = null;
	}
}

/* 递归写法
public void connect(TreeLinkNode root) {
	if (root == null) {
		return;
	}
	TreeLinkNode dummy = new TreeLinkNode(-1);
	TreeLinkNode p = dummy;
	for (TreeLinkNode cur = root; cur != null; cur = cur.next) {
		if (cur.left != null) {
			p.next = cur.left;
			p = p.next;
		}
		if (cur.right != null) {
			p.next = cur.right;
			p = p.next;
		}
	}
	p.next = null;
	connect(dummy.next);
}
*/

207. Course Schedule
There are a total of n courses you have to take, labeled from 0 to n - 1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

For example:

2, [[1,0]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.

2, [[1,0],[0,1]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.

Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.

click to show more hints.

Hints:
This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.
Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.
Topological sort could also be done via BFS.

public boolean canFinish(int numCourses, int[][] prerequisites) {
    boolean[][] matrix = new boolean[numCourses][numCourses];
    int[] indegree = new int[numCourses];

    for (int i = 0; i < prerequisites.length; i++) {
        int cur = prerequisites[i][0];
        int pre = prerequisites[i][1];

        if (!matrix[pre][cur]) {
            indegree[cur]++;
        }

        matrix[pre][cur] = true;
    }

    Queue<Integer> queue = new LinkedList<Integer>();

    for (int i = 0; i < numCourses; i++) {
        if (indegree[i] == 0) {
            queue.add(i);
        }
    }

    int count = 0;

    while (!queue.isEmpty()) {
        int course = queue.poll();

        count++;

        for (int i = 0; i < numCourses; i++) {
            if (matrix[course][i]) {
                matrix[course][i] = false;
                if (--indegree[i] == 0) {
                    queue.add(i);
                }
            }
        }
    }

    return count == numCourses;   
}

210. Course Schedule II
There are a total of n courses you have to take, labeled from 0 to n - 1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.

There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.

For example:

2, [[1,0]]
There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]

4, [[1,0],[2,0],[3,1],[3,2]]
There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].

Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.

click to show more hints.

Hints:
This problem is equivalent to finding the topological order in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.
Topological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.
Topological sort could also be done via BFS.

public int[] findOrder(int numCourses, int[][] prerequisites) {
    boolean[][] matrix = new boolean[numCourses][numCourses];
    int[] indegree = new int[numCourses];

    for (int i = 0; i < prerequisites.length; i++) {
        int cur = prerequisites[i][0];
        int pre = prerequisites[i][1];
        if (!matrix[pre][cur]) {
            indegree[cur]++;
        }
        matrix[pre][cur] = true;
    }

    Queue<Integer> queue = new LinkedList<Integer>();
    for (int i = 0; i < numCourses; i++) {
        if (indegree[i] == 0) {
            queue.add(i);
        }
    }

    int count = 0;

    int[] result = new int[numCourses];

    while (!queue.isEmpty()) {
        int course = queue.poll();

        result[count++] = course;

        for (int i = 0; i < numCourses; i++) {
            if (matrix[course][i]) {
                matrix[course][i] = false;
                if (--indegree[i] == 0) {
                    queue.add(i);
                }
            }
        }
    }

    return count == numCourses ? result : new int[0];
}

85. Maximal Rectangle
Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

For example, given the following matrix:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
Return 6.

// 耗时10ms，时间复杂度是O(mn)，空间复杂度O(n)
public int maximalRectangle(char[][] matrix) {
	if (matrix.length == 0) {
		return 0;
	}
	int row = matrix.length, col = matrix[0].length, max = 0;
	int[] heights = new int[col];
	for (int i = 0; i < row; i++) {
		for (int j = 0; j < col; j++) {
			if (matrix[i][j] == '0') {
				heights[j] = 0;
			} else {
				heights[j]++;
			}
		}
		max = Math.max(max, largestRectangleArea(heights));
	}
	return max;
}

// 耗时9ms
public int maximalRectangle2(char[][] matrix) {
	if (matrix.length == 0) {
		return 0;
	}

	int row = matrix.length, col = matrix[0].length, area = 0;
	int[] height = new int[col], left = new int[col], right = new int[col];
	for (int i = 0; i < col; right[i] = col - 1, i++);

	for (int i = 0; i < row; i++) {
		int leftStart = 0, rightStart = col - 1;

		for (int j = 0; j < col; j++) {
			if (matrix[i][j] == '0') {
				height[j] = 0;
			} else {
				height[j]++;
			}
		}

		// 注意当matrix[i][j]为0时其实left[j]和right[j]是多少已经不重要了，因为
		// height[j]为0，所以这里算left[j]和right[j]只是为了方便计算下一层
		// 所以left[j]=0好理解，而right[j]=col-1的目的是为了设置成最大的，因为下一层要求min

		for (int j = 0; j < col; j++) {
			if (matrix[i][j] == '0') {
				left[j] = 0;
				leftStart = j + 1;
			} else {
				left[j] = Math.max(left[j], leftStart);
			}
		}

		for (int j = col - 1; j >= 0; j--) {
			if (matrix[i][j] == '0') {
				right[j] = col - 1;
				rightStart = j - 1;
			} else {
				right[j] = Math.min(right[j], rightStart);
			}
		}

		for (int j = 0; j < col; j++) {
			area = Math.max(area, (right[j] - left[j] + 1) * height[j]);
		}
	}

	return area;
}

234. Palindrome Linked List
Given a singly linked list, determine if it is a palindrome.

Follow up:
Could you do it in O(n) time and O(1) space?

// 耗时2ms
public boolean isPalindrome(ListNode head) {
	ListNode half = head;

	int len = 0;
	for (ListNode p = head; p != null && p.next != null; p = p.next.next, half = half.next) {
		len++;
	}

	half = reverse(half);

	for (int i = 0; i < len; i++, half = half.next, head = head.next) {
		if (half.val != head.val) {
			return false;
		}
	}

	return true;
}

private ListNode reverse(ListNode head) {
	ListNode dummy = new ListNode(0);
	for (ListNode p = head; p != null; ) {
		ListNode next = p.next;
		p.next = dummy.next;
		dummy.next = p;
		p = next;
	}
	return dummy.next;
}

25. Reverse Nodes in k-Group
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

You may not alter the values in the nodes, only nodes itself may be changed.

Only constant memory is allowed.

For example,
Given this linked list: 1->2->3->4->5

For k = 2, you should return: 2->1->4->3->5

For k = 3, you should return: 3->2->1->4->5

public ListNode reverseKGroup(ListNode head, int k) {
	if (head == null || k == 1) {
		return head;
	}
	int size = 0;
	ListNode dummy = new ListNode(0);
	for (ListNode p = head; p != null; p = p.next, size++);

	for (ListNode cur = dummy, p = head; p != null; ) {
		if (size < k) {
			cur.next = p;
			break;
		}
		ListNode tail = p;
		for (int i = 0; i < k; i++) {
			ListNode next = p.next;
			p.next = cur.next;
			cur.next = p;
			p = next;
		}
		size -= k;
		cur = tail;
		cur.next = null;
	}
	return dummy.next;
}

261. Graph Valid Tree
Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

For example:

Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.

Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.

Hint:

Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree?
According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”
Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.


26. Remove Duplicates from Sorted Array
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

For example,
Given input array nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.

Show Company Tags
Show Tags
Show Similar Problems

public int removeDuplicates(int[] nums) {
	int j = -1;
	for (int i = 0; i < nums.length; i++) {
		if (j == -1 || nums[i] != nums[j]) {
			nums[++j] = nums[i];
		}
	}
	return j + 1;
}

80. Remove Duplicates from Sorted Array II
Follow up for "Remove Duplicates":
What if duplicates are allowed at most twice?

For example,
Given sorted array nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.

public int removeDuplicates(int[] nums) {
	int j = -1;
	for (int i = 0; i < nums.length; i++) {
		if (j < 1 || nums[i] != nums[j - 1]) {
			nums[++j] = nums[i];
		}
	}
	return j + 1;
}

83. Remove Duplicates from Sorted List
Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,
Given 1->1->2, return 1->2.
Given 1->1->2->3->3, return 1->2->3.

public ListNode deleteDuplicates(ListNode head) {
	ListNode dummy = new ListNode(0), cur = dummy;
	for ( ; head != null; head = head.next) {
		if (cur == dummy || head.val != cur.val) {
			cur.next = head;
			cur = cur.next;
		}
	}
	cur.next = null;
	return dummy.next;
}

82. Remove Duplicates from Sorted List II
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

For example,
Given 1->2->3->3->4->4->5, return 1->2->5.
Given 1->1->1->2->3, return 2->3.

public ListNode deleteDuplicates(ListNode head) {
	if (head == null) {
		return null;
	}

	ListNode dummy = new ListNode(0), tail = dummy;
	ListNode prev = head, cur = head.next;

	for ( ; cur != null; cur = cur.next) {
		if (prev.val != cur.val) {
			if (prev.next == cur) {
				tail.next = prev;
				tail = tail.next;
			}
			prev = cur;
		}
	}

	tail.next = prev.next == null ? prev : null;
	return dummy.next;
}

168. Excel Sheet Column Title
Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
	
public String convertToTitle(int n) {
    StringBuffer sf = new StringBuffer();
    for ( ; n > 0; n /= 26) {
        int k = n % 26;
        if (k == 0) {
            n -= 26;
            sf.insert(0, 'Z');
        } else {
            n -= k;
            sf.insert(0, (char) ('A' + k - 1));
        }
    }
    return sf.toString();
}

256. Paint House
There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.

Note:
All costs are positive integers.




265. Paint House II
There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.

The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.

Note:
All costs are positive integers.

Follow up:
Could you solve it in O(nk) runtime?




404. Sum of Left Leaves
Find the sum of all left leaves in a given binary tree.

Example:

    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.

public int sumOfLeftLeaves(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int left = 0;

    if (root.left != null && root.left.left == null && root.left.right == null) {
        left = root.left.val;
    } else {
        left = sumOfLeftLeaves(root.left);
    }

    return left + sumOfLeftLeaves(root.right);
}

410. Split Array Largest Sum
Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.

Note:
Given m satisfies the following constraint: 1 ≤ m ≤ length(nums) ≤ 14,000.

Examples:

Input:
nums = [7,2,5,10,8]
m = 2

Output:
18

Explanation:
There are four ways to split nums into two subarrays.
The best way is to split it into [7,2,5] and [10,8],
where the largest sum among the two subarrays is only 18.

